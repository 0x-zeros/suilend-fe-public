var h=Object.defineProperty;var m=(i,e,t)=>e in i?h(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>m(i,typeof e!="symbol"?e+"":e,t);import{b9 as w,cs as g,d1 as p,ax as u,cb as l}from"../main.js";import{A as f}from"./aptos-C0JHIRUy.js";class c{constructor(e,t,r,s){o(this,"network");o(this,"chain");o(this,"connection");o(this,"contracts");o(this,"chainId");o(this,"coreBridge");this.network=e,this.chain=t,this.connection=r,this.contracts=s,this.chainId=w(t);const n=s.coreBridge;if(!n)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridge=n}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,s]=await f.chainFromRpc(e),n=t[s];if(n.network!==r)throw new Error(`Network mismatch: ${n.network} !== ${r}`);return new c(r,s,e,n.contracts)}async*publishMessage(e,t){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(r=>({chain:r.emitterChain,emitter:r.emitterAddress,sequence:r.sequence}))}async parseMessages(e){const t=await this.connection.getTransactionByHash(e);if(t.type!=="user_transaction")throw new Error(`${e} is not a user_transaction`);const s=t.events.filter(n=>n.type.endsWith("WormholeMessage"));if(!s||s.length===0)throw new Error(`WormholeMessage not found for ${e}`);return s.map(n=>{const a=n.data,d=new g(BigInt(a.sender).toString(16).padStart(64,"0"));return p("Uint8Array",{guardianSet:0,emitterChain:this.chain,emitterAddress:d,sequence:BigInt(a.sequence),timestamp:Number(a.timestamp),consistencyLevel:a.consistency_level,nonce:Number(a.nonce),signatures:[],payload:u.decode(a.payload)})})}}l("Aptos","WormholeCore",c);export{c as AptosWormholeCore};
