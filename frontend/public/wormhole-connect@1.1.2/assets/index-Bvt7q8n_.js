var Q=Object.defineProperty;var X=(O,e,t)=>e in O?Q(O,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):O[e]=t;var d=(O,e,t)=>X(O,typeof e!="symbol"?e+"":e,t);import{A as C,S as g,a as Y}from"./index-Cf0vrSY4.js";import{dF as Z,b6 as S,b9 as $,du as _,bC as I,dG as F,dx as q,c5 as tt,cI as b,cs as et,aF as z,cx as H,dy as y,ds as u,dz as k,dC as U,c6 as L,dt as K,dH as st,dI as G,dJ as ot,cb as nt,bz as rt}from"../main.js";import{A as at}from"./algorand-Dh1Hxry5.js";const J=Z.fromSignature("portal_transfer(byte[])byte[]"),c=class c{constructor(e,t,n,o){d(this,"network");d(this,"chain");d(this,"connection");d(this,"contracts");d(this,"chainId");d(this,"coreBridge");d(this,"coreAppId");d(this,"coreAppAddress");d(this,"tokenBridgeAppId");d(this,"tokenBridgeAddress");if(this.network=e,this.chain=t,this.connection=n,this.contracts=o,this.chainId=$(t),!o.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const r=BigInt(o.coreBridge);if(this.coreAppId=r,this.coreAppAddress=_(r),this.coreBridge=new C(e,t,n,o),!o.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const a=BigInt(o.tokenBridge);this.tokenBridgeAppId=a,this.tokenBridgeAddress=_(a)}static async fromRpc(e,t){const[n,o]=await at.chainFromRpc(e),r=t[o];if(r.network!==n)throw new Error(`Network mismatch: ${r.network} != ${n}`);return new c(n,o,e,r.contracts)}async isWrappedAsset(e){const t=new I(e).toInt();if(t===0)return!1;const n=await this.connection.getAssetByID(t).do(),r=F.from_obj_for_encoding(n).params.creator,a=await this.connection.accountInformation(r).exclude("all").do(),s=q.from_obj_for_encoding(a);return(s==null?void 0:s.authAddr)===this.tokenBridgeAddress}async getOriginalAsset(e){const t=new I(e).toInt(),n=await this.connection.getAssetByID(t).do(),o=F.from_obj_for_encoding(n),r=await g.decodeLocalState(this.connection,this.tokenBridgeAppId,o.params.creator);if(r.length<94)throw new Error("Invalid local state data");const a=r.slice(92,94),s=tt(b.decode(a)),p=new et(r.slice(60,92));return{chain:s,address:p}}async getTokenUniversalAddress(e){return new I(e).toUniversalAddress()}async getTokenNativeAddress(e,t){return new I(t).toNative()}async getWrappedAsset(e){if(z(e.address))throw new Error("native asset cannot be a wrapped asset");const t=g.forWrappedAsset(this.tokenBridgeAppId,e),n=await g.decodeLocalState(this.connection,this.tokenBridgeAppId,t.address());if(n.length<8)throw new Error("Invalid wrapped asset data");return H(this.chain,b.decode(n.slice(0,8)).toString())}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedNative(){return H(this.chain,"0")}async isTransferCompleted(e){const t=g.forMessageId(this.tokenBridgeAppId,{sequence:e.sequence,chain:e.emitterChain,emitter:e.emitterAddress});try{return await g.checkBitsSet(this.connection,this.tokenBridgeAppId,t.address(),e.sequence)}catch{}return!1}async*createAttestation(e,t){if(!t)throw new Error("Payer required to create attestation");const n=new I(t).toString(),o=new I(e).toInt(),r=[],a=await this.connection.getTransactionParams().do(),s=g.forEmitter(this.coreAppId,new I(this.tokenBridgeAddress).toUint8Array()),{accounts:[p],txs:w}=await C.maybeCreateStorageTx(this.connection,n,this.coreAppId,s,a);r.push(...w);let f="",i;if(o!==0){const l=await this.connection.getAssetByID(o).do(),j=F.from_obj_for_encoding(l),E=await this.connection.accountInformation(j.params.creator).do();if(i=q.from_obj_for_encoding(E),i.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const T=g.forNativeAsset(this.tokenBridgeAppId,BigInt(o)),B=await C.maybeCreateStorageTx(this.connection,n,this.tokenBridgeAppId,T);f=B.accounts[0],r.push(...B.txs);const m=y({from:n,appIndex:u(this.tokenBridgeAppId),onComplete:k.NoOpOC,appArgs:[c.noop],suggestedParams:a});r.push({tx:m});const A=await this.coreBridge.getMessageFee();if(A>BigInt(0)){const l=U({from:n,suggestedParams:a,to:this.tokenBridgeAddress,amount:A});r.push({tx:l})}let W=[p,f,this.coreAppAddress];i&&W.push(i.address);let h=y({appArgs:[c.attestToken,b.toBytes(o,8)],accounts:W,appIndex:u(this.tokenBridgeAppId),foreignApps:[u(this.coreAppId)],foreignAssets:[o],from:n,onComplete:k.NoOpOC,suggestedParams:a});A>BigInt(0)?h.fee*=3:h.fee*=2,r.push({tx:h});for(const l of r)yield this.createUnsignedTx(l,"TokenBridge.createAttestation",!0)}async*submitAttestation(e,t,n){if(!t)throw new Error("Sender required to submit attestation");n||(n=await this.connection.getTransactionParams().do());const o=t.toString(),a=g.forWrappedAsset(this.tokenBridgeAppId,e.payload.token).address(),s=[],p=[],w=await g.decodeLocalState(this.connection,this.tokenBridgeAppId,a);w.length>8&&p.push(new I(w.slice(0,8)).toInt()),s.push({tx:U({from:o,to:a,amount:1e5,suggestedParams:n})});let f=new Uint8Array(1);f[0]=1,s.push({tx:y({appArgs:[c.noop,f],appIndex:u(this.tokenBridgeAppId),from:o,onComplete:k.NoOpOC,suggestedParams:n})}),f=new Uint8Array(1),f[0]=2,s.push({tx:y({appArgs:[c.noop,f],appIndex:u(this.tokenBridgeAppId),from:o,onComplete:k.NoOpOC,suggestedParams:n})}),s.push({tx:y({accounts:[],appArgs:[c.receiveAttest,L(e)],appIndex:u(this.tokenBridgeAppId),foreignAssets:p,from:o,onComplete:k.NoOpOC,suggestedParams:n})}),s[s.length-1].tx.fee=s[s.length-1].tx.fee*2;for(const i of s)yield this.createUnsignedTx(i,"TokenBridge.submitAttestation",!0)}async*transfer(e,t,n,o,r){const a=e.toString(),s=z(n)?0:new I(n).toInt(),p=o,w=$(t.chain),f=t.address.toUniversalAddress().toUint8Array(),i=await this.connection.getTransactionParams().do(),T=BigInt(0),B=g.fromData({appId:this.coreAppId,appAddress:K(this.coreAppAddress).publicKey,idx:BigInt(0),address:K(this.tokenBridgeAddress).publicKey}),m=[],{accounts:[A],txs:W}=await C.maybeCreateStorageTx(this.connection,a,this.coreAppId,B,i);m.push(...W);let h="",l,j=!1;if(s!==0){const x=await this.connection.getAssetByID(s).do();h=F.from_obj_for_encoding(x).params.creator;const R=await this.connection.accountInformation(h).do();l=q.from_obj_for_encoding(R),j=l.authAddr===this.tokenBridgeAddress.toString()}const E=await this.coreBridge.getMessageFee();if(E>0&&m.push({tx:U({from:a,to:this.tokenBridgeAddress,amount:E,suggestedParams:i})}),!j){const x=g.forNativeAsset(this.tokenBridgeAppId,BigInt(s)),{accounts:[N],txs:R}=await C.maybeCreateStorageTx(this.connection,a,this.tokenBridgeAppId,x,i);h=N,R.push(...R)}if(s!==0&&!await c.isOptedInToAsset(this.connection,h,s)){const x=U({from:a,to:h,amount:1e5,suggestedParams:i});let N=y({from:a,appIndex:u(this.tokenBridgeAppId),onComplete:k.NoOpOC,appArgs:[c.optIn,st(s,8)],foreignAssets:[s],accounts:[h],suggestedParams:i});N.fee*=2,m.unshift({tx:x},{tx:N})}const V=y({from:a,appIndex:u(this.tokenBridgeAppId),onComplete:k.NoOpOC,appArgs:[c.noop],suggestedParams:i});m.push({tx:V});let v=[];if(s===0){const x=U({from:a,to:h,amount:p,suggestedParams:i});m.push({tx:x}),v=[A,h,h]}else{const x=G({from:a,to:h,amount:p,assetIndex:s,suggestedParams:i});m.push({tx:x}),v=l!=null&&l.address?[A,h,l.address]:[A,h]}const M=[c.sendTransfer,b.toBytes(s,8),b.toBytes(p,8),f,b.toBytes(w,8),b.toBytes(T,8)];r&&M.push(r);const P=y({from:a,appIndex:u(this.tokenBridgeAppId),onComplete:k.NoOpOC,appArgs:M,foreignApps:[u(this.coreAppId)],foreignAssets:[s],accounts:v,suggestedParams:i});P.fee*=2,m.push({tx:P});for(const x of m)yield this.createUnsignedTx(x,"TokenBridge.transfer",!0)}async*redeem(e,t,n=!0,o){o||(o=await this.connection.getTransactionParams().do());const r=new I(e).toString(),{accounts:a,txs:s}=await C.submitVAAHeader(this.connection,this.coreAppId,this.tokenBridgeAppId,t,r);let p,w="",f=[],i=0;if(t.payload.token.chain!==this.chain){p=g.forWrappedAsset(this.tokenBridgeAppId,t.payload.token),w=p.address();const A=await g.decodeLocalState(this.connection,this.tokenBridgeAppId,w);i=new I(A.slice(0,8)).toInt()}else{const A=new I(t.payload.token.address).toBigInt();p=g.forNativeAsset(this.tokenBridgeAppId,A),w=p.address(),i=u(A)}a.push(w);let T=0,B="";if(t.payloadName==="TransferWithPayload"?(T=new I(t.payload.to.address).toInt(),B=_(T)):B=new I(t.payload.to.address.toUint8Array()).toString(),a.push(B),i!==0&&(f.push(i),!await c.isOptedInToAsset(this.connection,B,i))){if(r!=B)throw new Error("Cannot ASA optin for somebody else (asset "+i.toString()+")");s.unshift({tx:G({amount:0,assetIndex:i,from:r,suggestedParams:o,to:r})})}const m={accounts:a,appArgs:[c.completeTransfer,L(t)],appIndex:u(this.tokenBridgeAppId),foreignAssets:f,from:r,onComplete:k.NoOpOC,suggestedParams:o};s.push({tx:y(m)}),s[s.length-1].tx.fee=s[s.length-1].tx.fee*(t.payloadName==="Transfer"&&t.payload.fee!==void 0&&t.payload.fee===0n?2:3),t.payloadName==="TransferWithPayload"&&(s[s.length-1].tx.appForeignApps=[T],s.push({tx:y({appArgs:[J.getSelector(),J.args[0].type.encode(L(t))],appIndex:T,foreignAssets:f,from:r,onComplete:k.NoOpOC,suggestedParams:o})}));for(const A of s)yield this.createUnsignedTx(A,"TokenBridge.redeem",!0)}static async isOptedInToAsset(e,t,n){var o;try{const r=await e.accountAssetInformation(t,n).do();return(((o=ot.from_obj_for_encoding(r).assetHolding)==null?void 0:o.amount)??0)>0}catch{}return!1}createUnsignedTx(e,t,n=!0){return new Y(e,this.network,this.chain,t,n)}};d(c,"sendTransfer",S.encode("sendTransfer")),d(c,"attestToken",S.encode("attestToken")),d(c,"noop",S.encode("nop")),d(c,"optIn",S.encode("optin")),d(c,"completeTransfer",S.encode("completeTransfer")),d(c,"receiveAttest",S.encode("receiveAttest"));let D=c;nt(rt,"TokenBridge",D);export{D as AlgorandTokenBridge,J as TransferMethodSelector};
