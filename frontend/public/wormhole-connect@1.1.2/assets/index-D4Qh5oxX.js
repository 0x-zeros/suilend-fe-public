var h=Object.defineProperty;var p=(c,e,t)=>e in c?h(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var a=(c,e,t)=>p(c,typeof e!="symbol"?e+"":e,t);import{C as w}from"./cosmwasm-CyUc9Vh-.js";import{d1 as g,cs as l,ax as m,cb as u,ba as f}from"../main.js";import"./pako.esm-BmRJ7v9o.js";import"./pbkdf2-hgtI6hs6.js";import"./index-38TDOvlh.js";import"./index-BJd0Ft1W.js";import"./keccak-D5KiXXoh.js";import"./sha3-BCR3lxOA.js";import"./index-kXg7_kw1.js";class i{constructor(e,t,s,r){a(this,"network");a(this,"chain");a(this,"rpc");a(this,"contracts");a(this,"coreAddress");this.network=e,this.chain=t,this.rpc=s,this.contracts=r;const o=this.contracts.coreBridge;if(!o)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.coreAddress=o}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[s,r]=await w.chainFromRpc(e),o=t[r];if(o.network!==s)throw new Error(`Network mismatch: ${o.network} != ${s}`);return new i(s,r,e,o.contracts)}async*publishMessage(e,t,s,r){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[i.parseWormholeMessageId(this.chain,this.coreAddress,t)]}async parseMessages(e){const t=await this.rpc.getTx(e);if(!t)throw new Error("No transaction found for txid: "+e);return[i.parseWormholeMessage(this.chain,this.coreAddress,t)]}static parseWormholeMessage(e,t,s){const r=s.events.filter(n=>n.type==="wasm"&&n.attributes[0].key==="_contract_address"&&n.attributes[0].value===t);if(r.length===0)throw new Error("No wormhole message found in tx");r.length>1&&console.error(`Expected single message, found ${r.length}`);const[o]=r,d=Object.fromEntries(o.attributes.map(n=>[n.key.split(".")[1],n.value]));return g("Uint8Array",{emitterChain:e,emitterAddress:new l(m.decode(d.sender)),sequence:BigInt(d.sequence),guardianSet:0,timestamp:Number(d.block_time),consistencyLevel:0,nonce:Number(d.nonce),signatures:[],payload:m.decode(d.message)})}static parseWormholeMessageId(e,t,s){const r=i.parseWormholeMessage(e,t,s);return{chain:r.emitterChain,emitter:r.emitterAddress,sequence:r.sequence}}}u(f,"WormholeCore",i);export{i as CosmwasmWormholeCore};
