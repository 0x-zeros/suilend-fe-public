var N=Object.defineProperty;var x=(h,t,e)=>t in h?N(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e;var c=(h,t,e)=>x(h,typeof t!="symbol"?t+"":t,e);import"./index-D4Qh5oxX.js";import{C as l,G as v}from"./cosmwasm-CyUc9Vh-.js";import{b as o,c as g,C as W}from"./unsignedTransaction-CU1N6MiT.js";import{aF as u,aZ as d,b9 as B,cx as S,b5 as a,c5 as E,cs as q,c6 as y,cb as I,ba as D}from"../main.js";import"./pako.esm-BmRJ7v9o.js";import"./pbkdf2-hgtI6hs6.js";import"./index-38TDOvlh.js";import"./index-BJd0Ft1W.js";import"./keccak-D5KiXXoh.js";import"./sha3-BCR3lxOA.js";import"./index-kXg7_kw1.js";class k{constructor(t,e,r,s){c(this,"network");c(this,"chain");c(this,"rpc");c(this,"contracts");c(this,"tokenBridge");c(this,"translator");this.network=t,this.chain=e,this.rpc=r,this.contracts=s;const n=this.contracts.tokenBridge;if(!n)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);if(this.tokenBridge=n,this.translator=this.contracts.translator,this.translator!==void 0&&this.translator==="")throw new Error("Translator address may be undefined but not empty string")}static async fromRpc(t,e){const[r,s]=await l.chainFromRpc(t),n=e[s];if(n.network!==r)throw new Error(`Network mismatch: ${n.network} != ${r}`);return new k(r,s,t,e[s].contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{}return!1}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(t.chain===this.chain)throw new Error(`Expected foreign chain, got ${t.chain}`);if(u(t.address))throw new Error("Native asset cannot be a wrapped asset");const e=d.encode(t.address.toUniversalAddress().toUint8Array()),{address:r}=await this.rpc.queryContractSmart(this.tokenBridge,{wrapped_registry:{chain:B(t.chain),address:e}});return S(this.chain,r)}async getOriginalAsset(t){let e=new a(t);e.denomType==="factory"&&(e=v.factoryToCw20(e));const r=await this.rpc.queryContractSmart(e.toString(),{wrapped_asset_info:{}}),s=E(r.asset_chain),n=d.decode(r.asset_address);return{chain:s,address:new q(new Uint8Array(n))}}async getTokenUniversalAddress(t){return new a(t).toUniversalAddress()}async getTokenNativeAddress(t,e){return new a(e).toNative()}async isTransferCompleted(t){const e=d.encode(y(t));return(await this.rpc.queryContractSmart(this.tokenBridge,{is_vaa_redeemed:{vaa:e}})).is_redeemed}async*createAttestation(t,e){if(!e)throw new Error("Payer required to create attestation");const r=new a(t).toString(),s=new a(e).toString(),n=0,w=u(t)?{native_token:{denom:l.getNativeDenom(this.network,this.chain)}}:{token:{contract_addr:r}};yield this.createUnsignedTx({msgs:[o(s,this.tokenBridge,{create_asset_meta:{asset_info:w,nonce:n}})],fee:g(this.network,this.chain),memo:"Wormhole - Create Attestation"},"TokenBridge.createAttestation")}async*submitAttestation(t,e){if(!e)throw new Error("Payer required to submit attestation");const r=new a(e).toString();yield this.createUnsignedTx({msgs:[o(r,this.tokenBridge,{submit_vaa:{data:y(t)}})],fee:g(this.network,this.chain),memo:"Wormhole - Submit Attestation"},"TokenBridge.submitAttestation")}async*transfer(t,e,r,s,n){const w=Math.round(Math.random()*1e5),f="0",C=B(e.chain),b=d.encode(e.address.toUniversalAddress().toUint8Array()),U=l.getNativeDenom(this.network,this.chain),A=u(r);let i=A?U:r.toString();i.startsWith("factory")&&(i=v.factoryToCw20(new a(i)).toString());const p=new a(t).toString(),_=m=>{const T={asset:{amount:s.toString(),info:m},recipient_chain:C,recipient:b,fee:f,nonce:w};return n?{initiate_transfer_with_payload:{...T,payload:d.encode(n)}}:{initiate_transfer:T}};if(A){const m=[o(p,this.tokenBridge,{deposit_tokens:{}},[{amount:s.toString(),denom:i}]),o(p,this.tokenBridge,_({native_token:{denom:i}}))];yield this.createUnsignedTx({msgs:m,fee:g(this.network,this.chain),memo:"Wormhole - Initiate Native Transfer"},"TokenBridge.transferNative")}else{const m=[o(p,i,{increase_allowance:{spender:this.tokenBridge,amount:s.toString(),expires:{never:{}}}}),o(p,this.tokenBridge,_({token:{contract_addr:i}}),[{amount:s.toString(),denom:i}])];yield this.createUnsignedTx({msgs:m,fee:g(this.network,this.chain),memo:"Wormhole - Initiate Transfer"},"TokenBridge.transfer")}}async*redeem(t,e,r=!0){const s=d.encode(y(e)),n=new a(t).toString(),f=this.translator&&new a(this.translator).toUniversalAddress().equals(e.payload.to.address)?o(n,this.translator,{complete_transfer_and_convert:{vaa:s}}):o(n,this.tokenBridge,{submit_vaa:{data:s}});yield this.createUnsignedTx({msgs:[f],fee:g(this.network,this.chain),memo:"Wormhole - Complete Transfer"},"TokenBridge.redeem")}async parseTransactionDetails(t){throw new Error("Not implemented")}async getWrappedNative(){return S(this.chain,l.getNativeDenom(this.network,this.chain))}createUnsignedTx(t,e,r=!1){return new W(t,this.network,this.chain,e,r)}}I(D,"TokenBridge",k);export{k as CosmwasmTokenBridge};
