var Zr=Object.defineProperty;var Yr=(t,e,r)=>e in t?Zr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var C=(t,e,r)=>Yr(t,typeof e!="symbol"?e+"":e,r);import{s as Qr,aS as en,d8 as ft,aY as tn,d9 as hr,da as ke,bh as rn,cr as nt,c5 as nn,cs as nr,b9 as ce,a$ as ge,aF as oe,c2 as sn,cx as ir,cu as an,db as on,c6 as ht,aZ as cn,ax as De,b6 as un,cI as sr,dc as dn,a_ as ar,cb as gr}from"../main.js";import{g as tt,a as gt,i as Ve,S as Q,b as H,p as ln,c as fn,d as it,u as ze,e as pr,f as hn,h as He,j as gn,k as pn}from"./sui-C9B6ygqd.js";import"./index-BWNV_2rz.js";import"./pbkdf2-hgtI6hs6.js";class yr{constructor(e,r,n,i,s=!1){C(this,"transaction");C(this,"network");C(this,"chain");C(this,"description");C(this,"parallelizable");this.transaction=e,this.network=r,this.chain=n,this.description=i,this.parallelizable=s}}class yn extends TypeError{constructor(e,r){let n;const{message:i,explanation:s,...c}=e,{path:a}=e,o=a.length===0?i:`At path: ${a.join(".")} -- ${i}`;super(s??o),s!=null&&(this.cause=o),Object.assign(this,c),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...r()])}}function mn(t){return L(t)&&typeof t[Symbol.iterator]=="function"}function L(t){return typeof t=="object"&&t!=null}function W(t){return typeof t=="symbol"?t.toString():typeof t=="string"?JSON.stringify(t):`${t}`}function wn(t){const{done:e,value:r}=t.next();return e?void 0:r}function bn(t,e,r,n){if(t===!0)return;t===!1?t={}:typeof t=="string"&&(t={message:t});const{path:i,branch:s}=e,{type:c}=r,{refinement:a,message:o=`Expected a value of type \`${c}\`${a?` with refinement \`${a}\``:""}, but received: \`${W(n)}\``}=t;return{value:n,type:c,refinement:a,key:i[i.length-1],path:i,branch:s,...t,message:o}}function*or(t,e,r,n){mn(t)||(t=[t]);for(const i of t){const s=bn(i,e,r,n);s&&(yield s)}}function*vt(t,e,r={}){const{path:n=[],branch:i=[t],coerce:s=!1,mask:c=!1}=r,a={path:n,branch:i};if(s&&(t=e.coercer(t,a),c&&e.type!=="type"&&L(e.schema)&&L(t)&&!Array.isArray(t)))for(const d in t)e.schema[d]===void 0&&delete t[d];let o="valid";for(const d of e.validator(t,a))d.explanation=r.message,o="not_valid",yield[d,void 0];for(let[d,u,g]of e.entries(t,a)){const m=vt(u,g,{path:d===void 0?n:[...n,d],branch:d===void 0?i:[...i,u],coerce:s,mask:c,message:r.message});for(const y of m)y[0]?(o=y[0].refinement!=null?"not_refined":"not_valid",yield[y[0],void 0]):s&&(u=y[1],d===void 0?t=u:t instanceof Map?t.set(d,u):t instanceof Set?t.add(u):L(t)&&(u!==void 0||d in t)&&(t[d]=u))}if(o!=="not_valid")for(const d of e.refiner(t,a))d.explanation=r.message,o="not_refined",yield[d,void 0];o==="valid"&&(yield[void 0,t])}class te{constructor(e){const{type:r,schema:n,validator:i,refiner:s,coercer:c=o=>o,entries:a=function*(){}}=e;this.type=r,this.schema=n,this.entries=a,this.coercer=c,i?this.validator=(o,d)=>{const u=i(o,d);return or(u,d,this,o)}:this.validator=()=>[],s?this.refiner=(o,d)=>{const u=s(o,d);return or(u,d,this,o)}:this.refiner=()=>[]}assert(e,r){return pt(e,this,r)}create(e,r){return mr(e,this,r)}is(e){return F(e,this)}mask(e,r){return wr(e,this,r)}validate(e,r={}){return Ce(e,this,r)}}function pt(t,e,r){const n=Ce(t,e,{message:r});if(n[0])throw n[0]}function mr(t,e,r){const n=Ce(t,e,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function wr(t,e,r){const n=Ce(t,e,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function F(t,e){return!Ce(t,e)[0]}function Ce(t,e,r={}){const n=vt(t,e,r),i=wn(n);return i[0]?[new yn(i[0],function*(){for(const c of n)c[0]&&(yield c[0])}),void 0]:[void 0,i[1]]}function Ae(...t){const e=t[0].type==="type",r=t.map(i=>i.schema),n=Object.assign({},...r);return e?Tn(n):p(n)}function G(t,e){return new te({type:t,schema:null,validator:e})}function yt(){return G("any",()=>!0)}function I(t){return new te({type:"array",schema:t,*entries(e){if(t&&Array.isArray(e))for(const[r,n]of e.entries())yield[r,n,t]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${W(e)}`}})}function Sn(){return G("bigint",t=>typeof t=="bigint")}function D(){return G("boolean",t=>typeof t=="boolean")}function ee(){return G("integer",t=>typeof t=="number"&&!isNaN(t)&&Number.isInteger(t)||`Expected an integer, but received: ${W(t)}`)}function T(t){const e=W(t),r=typeof t;return new te({type:"literal",schema:r==="string"||r==="number"||r==="boolean"?t:null,validator(n){return n===t||`Expected the literal \`${e}\`, but received: ${W(n)}`}})}function br(){return G("never",()=>!1)}function B(t){return new te({...t,validator:(e,r)=>e===null||t.validator(e,r),refiner:(e,r)=>e===null||t.refiner(e,r)})}function ye(){return G("number",t=>typeof t=="number"&&!isNaN(t)||`Expected a number, but received: ${W(t)}`)}function p(t){const e=t?Object.keys(t):[],r=br();return new te({type:"object",schema:t||null,*entries(n){if(t&&L(n)){const i=new Set(Object.keys(n));for(const s of e)i.delete(s),yield[s,n[s],t[s]];for(const s of i)yield[s,n[s],r]}},validator(n){return L(n)||`Expected an object, but received: ${W(n)}`},coercer(n){return L(n)?{...n}:n}})}function S(t){return new te({...t,validator:(e,r)=>e===void 0||t.validator(e,r),refiner:(e,r)=>e===void 0||t.refiner(e,r)})}function Y(t,e){return new te({type:"record",schema:null,*entries(r){if(L(r))for(const n in r){const i=r[n];yield[n,n,t],yield[n,i,e]}},validator(r){return L(r)||`Expected an object, but received: ${W(r)}`}})}function h(){return G("string",t=>typeof t=="string"||`Expected a string, but received: ${W(t)}`)}function Sr(t){const e=br();return new te({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(t.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],t[i]||e]}},validator(r){return Array.isArray(r)||`Expected an array, but received: ${W(r)}`}})}function Tn(t){const e=Object.keys(t);return new te({type:"type",schema:t,*entries(r){if(L(r))for(const n of e)yield[n,r[n],t[n]]},validator(r){return L(r)||`Expected an object, but received: ${W(r)}`},coercer(r){return L(r)?{...r}:r}})}function $(t){const e=t.map(r=>r.type).join(" | ");return new te({type:"union",schema:null,coercer(r){for(const n of t){const[i,s]=n.validate(r,{coerce:!0});if(!i)return s}return r},validator(r,n){const i=[];for(const s of t){const[...c]=vt(r,s,n),[a]=c;if(a[0])for(const[o]of c)o&&i.push(o);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${W(r)}`,...i]}})}function Tr(){return G("unknown",()=>!0)}const kt=$([p({AddressOwner:h()}),p({ObjectOwner:h()}),p({Shared:p({initial_shared_version:B(h())})}),T("Immutable")]);G("SuiJsonValue",()=>!0);const vn=$([p({u32:h()}),p({u64:h()}),p({f64:h()})]);p({attributes:Y(h(),B(vn)),featureFlags:Y(h(),D()),maxSupportedProtocolVersion:h(),minSupportedProtocolVersion:h(),protocolVersion:h()});$([h(),T("package")]);const de=p({digest:h(),objectId:h(),version:$([ye(),h(),Sn()])});p({owner:kt,reference:de});p({objectId:h(),sequenceNumber:h()});p({payment:I(de),owner:h(),price:h(),budget:h()});const kn=Ae(de,p({type:h(),owner:kt,previousTransaction:h()})),In=Y(h(),yt()),jn=Y(h(),Tr()),En=p({type:h(),fields:In,hasPublicTransfer:D()}),On=p({disassembled:jn}),An=$([Ae(En,p({dataType:T("moveObject")})),Ae(On,p({dataType:T("package")}))]),_n=p({type:h(),hasPublicTransfer:D(),version:h(),bcsBytes:h()}),xn=p({id:h(),moduleMap:Y(h(),h())}),Bn=$([Ae(_n,p({dataType:T("moveObject")})),Ae(xn,p({dataType:T("package")}))]);BigInt(1e9);const vr=p({code:h(),error:S(h()),object_id:S(h()),parent_object_id:S(h()),version:S(h()),digest:S(h())}),Cn=p({data:B(S(Y(h(),h()))),error:B(S(vr))}),$n=$([Cn,S(Y(h(),h()))]),kr=p({objectId:h(),version:h(),digest:h(),type:B(S(h())),content:B(S(An)),bcs:B(S(Bn)),owner:B(S(kt)),previousTransaction:B(S(h())),storageRebate:B(S(h())),display:B(S($n))});p({showType:B(S(D())),showContent:B(S(D())),showBcs:B(S(D())),showOwner:B(S(D())),showPreviousTransaction:B(S(D())),showStorageRebate:B(S(D())),showDisplay:B(S(D()))});$([T("Exists"),T("notExists"),T("Deleted")]);I(kn);const Un=p({data:B(S(kr)),error:B(S(vr))});function Rn(t){return t.data}function Pn(t){if(t.error&&"object_id"in t.error&&"version"in t.error&&"digest"in t.error){const e=t.error;return{objectId:e.object_id,version:e.version,digest:e.digest}}}function cr(t){if("reference"in t)return t.reference;const e=Rn(t);return e?{objectId:e.objectId,version:e.version,digest:e.digest}:Pn(t)}p({objectId:h(),atCheckpoint:S(ye())});p({data:I(Un),nextCursor:S(B(h())),hasNextPage:D()});$([p({details:kr,status:T("VersionFound")}),p({details:h(),status:T("ObjectNotExists")}),p({details:de,status:T("ObjectDeleted")}),p({details:Sr([h(),ye()]),status:T("VersionNotFound")}),p({details:p({asked_version:ye(),latest_version:ye(),object_id:h()}),status:T("VersionTooHigh")})]);const Mn=$([h(),p({Object:h()})]);I(Mn);const Nn=p({address:h(),name:h()}),Dn=$([T("Private"),T("Public"),T("Friend")]),It=p({abilities:I(h())}),Vn=p({constraints:It,isPhantom:D()}),zn=p({TypeParameter:ye()}),st=Sr([p({module:h(),package:h(),function:h()}),h()]);p({rank3Days:I(st),rank7Days:I(st),rank30Days:I(st)});function Ir(t){if(!t)return!1;if(typeof t=="string"||F(t,zn)||jr(t))return!0;if(typeof t!="object")return!1;const e=t;return!!(F(e.Reference,Se)||F(e.MutableReference,Se)||F(e.Vector,Se))}const Se=G("SuiMoveNormalizedType",Ir);function jr(t){if(!t||typeof t!="object")return!1;const e=t;if(!e.Struct||typeof e.Struct!="object")return!1;const r=e.Struct;return!(typeof r.address!="string"||typeof r.module!="string"||typeof r.name!="string"||!Array.isArray(r.typeArguments)||!r.typeArguments.every(n=>Ir(n)))}G("SuiMoveNormalizedStructType",jr);const Fn=p({visibility:Dn,isEntry:D(),typeParameters:I(It),parameters:I(Se),return:I(Se)}),Gn=p({name:h(),type:Se}),Ln=p({abilities:It,typeParameters:I(Vn),fields:I(Gn)}),Wn=p({fileFormatVersion:ye(),address:h(),name:h(),friends:I(Nn),structs:Y(h(),Ln),exposedFunctions:Y(h(),Fn)});Y(h(),Wn);function mt(t){return typeof t=="object"&&"MutableReference"in t?t.MutableReference:void 0}function Er(t){return typeof t=="object"&&"Reference"in t?t.Reference:void 0}function jt(t){if(typeof t=="object"&&"Struct"in t)return t;const e=Er(t),r=mt(t);if(typeof e=="object"&&"Struct"in e)return e;if(typeof r=="object"&&"Struct"in r)return r}function Kn(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var n=0;n<t.length;n++){var i=t.charAt(n),s=i.charCodeAt(0);if(e[s]!==255)throw new TypeError(i+" is ambiguous");e[s]=n}var c=t.length,a=t.charAt(0),o=Math.log(c)/Math.log(256),d=Math.log(256)/Math.log(c);function u(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var w=0,b=0,f=0,j=y.length;f!==j&&y[f]===0;)f++,w++;for(var _=(j-f)*d+1>>>0,U=new Uint8Array(_);f!==j;){for(var E=y[f],k=0,R=_-1;(E!==0||k<b)&&R!==-1;R--,k++)E+=256*U[R]>>>0,U[R]=E%c>>>0,E=E/c>>>0;if(E!==0)throw new Error("Non-zero carry");b=k,f++}for(var K=_-b;K!==_&&U[K]===0;)K++;for(var we=a.repeat(w);K<_;++K)we+=t.charAt(U[K]);return we}function g(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;for(var w=0,b=0,f=0;y[w]===a;)b++,w++;for(var j=(y.length-w)*o+1>>>0,_=new Uint8Array(j);y[w];){var U=e[y.charCodeAt(w)];if(U===255)return;for(var E=0,k=j-1;(U!==0||E<f)&&k!==-1;k--,E++)U+=c*_[k]>>>0,_[k]=U%256>>>0,U=U/256>>>0;if(U!==0)throw new Error("Non-zero carry");f=E,w++}for(var R=j-f;R!==j&&_[R]===0;)R++;for(var K=new Uint8Array(b+(j-R)),we=b;R!==j;)K[we++]=_[R++];return K}function m(y){var w=g(y);if(w)return w;throw new Error("Non-base"+c+" character")}return{encode:u,decodeUnsafe:g,decode:m}}var Jn=Kn;const Hn=Jn,Xn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var qn=Hn(Xn);const Or=Qr(qn),$e=t=>Or.encode(t),Et=t=>Or.decode(t);function le(t){return Uint8Array.from(atob(t),e=>e.charCodeAt(0))}const at=8192;function Ue(t){if(t.length<at)return btoa(String.fromCharCode(...t));let e="";for(var r=0;r<t.length;r+=at){const n=t.slice(r,r+at);e+=String.fromCharCode(...n)}return btoa(e)}function rt(t){var i;const e=t.startsWith("0x")?t.slice(2):t,n=((i=(e.length%2===0?e:`0${e}}`).match(/.{2}/g))==null?void 0:i.map(s=>parseInt(s,16)))??[];return Uint8Array.from(n)}function Re(t){return t.reduce((e,r)=>e+r.toString(16).padStart(2,"0"),"")}function Ot(t){let e=[],r=0;if(t===0)return[0];for(;t>0;)e[r]=t&127,(t>>=7)&&(e[r]|=128),r+=1;return e}function Zn(t){let e=0,r=0,n=0;for(;;){let i=t[n];if(n+=1,e|=(i&127)<<r,!(i&128))break;r+=7}return{value:e,length:n}}class Ar{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),n=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+n).toString(10)}read128(){let e=BigInt(this.read64()),n=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+n).toString(10)}read256(){let e=BigInt(this.read128()),n=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+n).toString(10)}readBytes(e){let r=this.bytePosition+this.dataView.byteOffset,n=new Uint8Array(this.dataView.buffer,r,e);return this.shift(e),n}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,e),{value:n,length:i}=Zn(r);return this.shift(i),n}readVec(e){let r=this.readULEB(),n=[];for(let i=0;i<r;i++)n.push(e(this,i,r));return n}}function Yn(t,e){switch(e){case"base58":return $e(t);case"base64":return Ue(t);case"hex":return Re(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Qn(t,e){switch(e){case"base58":return Et(t);case"base64":return le(t);case"hex":return rt(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function At(t,e=["<",">"]){const[r,n]=e,i=[];let s="",c=0;for(let a=0;a<t.length;a++){const o=t[a];if(o===r&&c++,o===n&&c--,c===0&&o===","){i.push(s.trim()),s="";continue}s+=o}return i.push(s.trim()),i}class _r{constructor({size:e=1024,maxSize:r,allocateSize:n=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=r||e,this.allocateSize=n,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const r=this.bytePosition+e;if(r>this.size){const n=Math.min(this.maxSize,this.size+this.allocateSize);if(r>n)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r}`);this.size=n;const i=new ArrayBuffer(this.size);new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(i)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return ot(BigInt(e),8).forEach(r=>this.write8(r)),this}write128(e){return ot(BigInt(e),16).forEach(r=>this.write8(r)),this}write256(e){return ot(BigInt(e),32).forEach(r=>this.write8(r)),this}writeULEB(e){return Ot(e).forEach(r=>this.write8(r)),this}writeVec(e,r){return this.writeULEB(e.length),Array.from(e).forEach((n,i)=>r(this,n,i,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return Yn(this.toBytes(),e)}}function ot(t,e){let r=new Uint8Array(e),n=0;for(;t>0;)r[n]=Number(t%BigInt(256)),t=t/BigInt(256),n+=1;return r}var xr=(t,e,r)=>{if(!e.has(t))throw TypeError("Cannot "+r)},X=(t,e,r)=>(xr(t,e,"read from private field"),r?r.call(t):e.get(t)),Xe=(t,e,r)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,r)},qe=(t,e,r,n)=>(xr(t,e,"write to private field"),e.set(t,r),r),be,Ie,Fe,ae;const Br=class{constructor(t){Xe(this,be,void 0),Xe(this,Ie,void 0),this.name=t.name,this.read=t.read,this.serializedSize=t.serializedSize??(()=>null),qe(this,be,t.write),qe(this,Ie,t.serialize??((e,r)=>{const n=new _r({size:this.serializedSize(e)??void 0,...r});return X(this,be).call(this,e,n),n.toBytes()})),this.validate=t.validate??(()=>{})}write(t,e){this.validate(t),X(this,be).call(this,t,e)}serialize(t,e){return this.validate(t),new ei(this,X(this,Ie).call(this,t,e))}parse(t){const e=new Ar(t);return this.read(e)}transform({name:t,input:e,output:r}){return new Br({name:t??this.name,read:n=>r(this.read(n)),write:(n,i)=>X(this,be).call(this,e(n),i),serializedSize:n=>this.serializedSize(e(n)),serialize:(n,i)=>X(this,Ie).call(this,e(n),i),validate:n=>this.validate(e(n))})}};let q=Br;be=new WeakMap;Ie=new WeakMap;const Cr=Symbol.for("@mysten/serialized-bcs");function _t(t){return!!t&&typeof t=="object"&&t[Cr]===!0}class ei{constructor(e,r){Xe(this,Fe,void 0),Xe(this,ae,void 0),qe(this,Fe,e),qe(this,ae,r)}get[Cr](){return!0}toBytes(){return X(this,ae)}toHex(){return Re(X(this,ae))}toBase64(){return Ue(X(this,ae))}toBase58(){return $e(X(this,ae))}parse(){return X(this,Fe).parse(X(this,ae))}}Fe=new WeakMap;ae=new WeakMap;function Ze({size:t,...e}){return new q({...e,serializedSize:()=>t})}function ct({readMethod:t,writeMethod:e,...r}){return Ze({...r,read:n=>n[t](),write:(n,i)=>i[e](n),validate:n=>{var i;if(n<0||n>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${n}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,n)}})}function ut({readMethod:t,writeMethod:e,...r}){return Ze({...r,read:n=>n[t](),write:(n,i)=>i[e](BigInt(n)),validate:n=>{var s;const i=BigInt(n);if(i<0||i>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${i}. Expected value in range 0-${r.maxValue}`);(s=r.validate)==null||s.call(r,i)}})}function ti({serialize:t,...e}){const r=new q({...e,serialize:t,write:(n,i)=>{for(const s of r.serialize(n).toBytes())i.write8(s)}});return r}function ri({toBytes:t,fromBytes:e,...r}){return new q({...r,read:n=>{const i=n.readULEB(),s=n.readBytes(i);return e(s)},write:(n,i)=>{const s=t(n);i.writeULEB(s.length);for(let c=0;c<s.length;c++)i.write8(s[c])},serialize:n=>{const i=t(n),s=Ot(i.length),c=new Uint8Array(s.length+i.length);return c.set(s,0),c.set(i,s.length),c},validate:n=>{var i;if(typeof n!="string")throw new TypeError(`Invalid ${r.name} value: ${n}. Expected string`);(i=r.validate)==null||i.call(r,n)}})}function ni(t){let e=null;function r(){return e||(e=t()),e}return new q({name:"lazy",read:n=>r().read(n),serializedSize:n=>r().serializedSize(n),write:(n,i)=>r().write(n,i),serialize:(n,i)=>r().serialize(n,i).toBytes()})}const l={u8(t){return ct({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...t})},u16(t){return ct({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...t})},u32(t){return ct({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...t})},u64(t){return ut({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...t})},u128(t){return ut({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...t})},u256(t){return ut({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...t})},bool(t){return Ze({name:"bool",size:1,read:e=>e.read8()===1,write:(e,r)=>r.write8(e?1:0),...t,validate:e=>{var r;if((r=t==null?void 0:t.validate)==null||r.call(t,e),typeof e!="boolean")throw new TypeError(`Expected boolean, found ${typeof e}`)}})},uleb128(t){return ti({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Ot(e)),...t})},bytes(t,e){return Ze({name:`bytes[${t}]`,size:t,read:r=>r.readBytes(t),write:(r,n)=>{for(let i=0;i<t;i++)n.write8(r[i]??0)},...e,validate:r=>{var n;if((n=e==null?void 0:e.validate)==null||n.call(e,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==t)throw new TypeError(`Expected array of length ${t}, found ${r.length}`)}})},string(t){return ri({name:"string",toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...t})},fixedArray(t,e,r){return new q({name:`${e.name}[${t}]`,read:n=>{const i=new Array(t);for(let s=0;s<t;s++)i[s]=e.read(n);return i},write:(n,i)=>{for(const s of n)e.write(s,i)},...r,validate:n=>{var i;if((i=r==null?void 0:r.validate)==null||i.call(r,n),!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`);if(n.length!==t)throw new TypeError(`Expected array of length ${t}, found ${n.length}`)}})},option(t){return l.enum(`Option<${t.name}>`,{None:null,Some:t}).transform({input:e=>e==null?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null})},vector(t,e){return new q({name:`vector<${t.name}>`,read:r=>{const n=r.readULEB(),i=new Array(n);for(let s=0;s<n;s++)i[s]=t.read(r);return i},write:(r,n)=>{n.writeULEB(r.length);for(const i of r)t.write(i,n)},...e,validate:r=>{var n;if((n=e==null?void 0:e.validate)==null||n.call(e,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`)}})},tuple(t,e){return new q({name:`(${t.map(r=>r.name).join(", ")})`,serializedSize:r=>{let n=0;for(let i=0;i<t.length;i++){const s=t[i].serializedSize(r[i]);if(s==null)return null;n+=s}return n},read:r=>{const n=[];for(const i of t)n.push(i.read(r));return n},write:(r,n)=>{for(let i=0;i<t.length;i++)t[i].write(r[i],n)},...e,validate:r=>{var n;if((n=e==null?void 0:e.validate)==null||n.call(e,r),!Array.isArray(r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==t.length)throw new TypeError(`Expected array of length ${t.length}, found ${r.length}`)}})},struct(t,e,r){const n=Object.entries(e);return new q({name:t,serializedSize:i=>{let s=0;for(const[c,a]of n){const o=a.serializedSize(i[c]);if(o==null)return null;s+=o}return s},read:i=>{const s={};for(const[c,a]of n)s[c]=a.read(i);return s},write:(i,s)=>{for(const[c,a]of n)a.write(i[c],s)},...r,validate:i=>{var s;if((s=r==null?void 0:r.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})},enum(t,e,r){const n=Object.entries(e);return new q({name:t,read:i=>{const s=i.readULEB(),[c,a]=n[s];return{[c]:(a==null?void 0:a.read(i))??!0}},write:(i,s)=>{const[c,a]=Object.entries(i)[0];for(let o=0;o<n.length;o++){const[d,u]=n[o];if(d===c){s.writeULEB(o),u==null||u.write(a,s);return}}},...r,validate:i=>{var a;if((a=r==null?void 0:r.validate)==null||a.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`);const s=Object.keys(i);if(s.length!==1)throw new TypeError(`Expected object with one key, found ${s.length}`);const[c]=s;if(!Object.hasOwn(e,c))throw new TypeError(`Invalid enum variant ${c}`)}})},map(t,e){return l.vector(l.tuple([t,e])).transform({name:`Map<${t.name}, ${e.name}>`,input:r=>[...r.entries()],output:r=>{const n=new Map;for(const[i,s]of r)n.set(i,s);return n}})},generic(t,e){return(...r)=>e(...r).transform({name:`${e.name}<${r.map(n=>n.name).join(", ")}>`,input:n=>n,output:n=>n})},lazy(t){return ni(t)}},ii=32,je=class{constructor(t){if(this.types=new Map,this.counter=0,t instanceof je){this.schema=t.schema,this.types=new Map(t.types);return}if(this.schema=t,this.registerAddressType(je.ADDRESS,t.addressLength,t.addressEncoding),this.registerVectorType(t.vectorType),t.types&&t.types.structs)for(let e of Object.keys(t.types.structs))this.registerStructType(e,t.types.structs[e]);if(t.types&&t.types.enums)for(let e of Object.keys(t.types.enums))this.registerEnumType(e,t.types.enums[e]);if(t.types&&t.types.aliases)for(let e of Object.keys(t.types.aliases))this.registerAlias(e,t.types.aliases[e]);t.withPrimitives!==!1&&si(this)}tempKey(){return`bcs-struct-${++this.counter}`}ser(t,e,r){if(typeof t=="string"||Array.isArray(t)){const{name:n,params:i}=this.parseTypeName(t);return this.getTypeInterface(n).encode(this,e,r,i)}if(typeof t=="object"){const n=this.tempKey();return new je(this).registerStructType(n,t).ser(n,e,r)}throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(t)}`)}de(t,e,r){if(typeof e=="string")if(r)e=Qn(e,r);else throw new Error("To pass a string to `bcs.de`, specify encoding");if(typeof t=="string"||Array.isArray(t)){const{name:n,params:i}=this.parseTypeName(t);return this.getTypeInterface(n).decode(this,e,i)}if(typeof t=="object"){const n=new je(this),i=this.tempKey();return n.registerStructType(i,t).de(i,e,r)}throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(t)}`)}hasType(t){return this.types.has(t)}registerAlias(t,e){return this.types.set(t,e),this}registerType(t,e,r,n=()=>!0){const{name:i,params:s}=this.parseTypeName(t);return this.types.set(i,{encode(c,a,o,d){const u=s.reduce((g,m,y)=>Object.assign(g,{[m]:d[y]}),{});return this._encodeRaw.call(c,new _r(o),a,d,u)},decode(c,a,o){const d=s.reduce((u,g,m)=>Object.assign(u,{[g]:o[m]}),{});return this._decodeRaw.call(c,new Ar(a),o,d)},_encodeRaw(c,a,o,d){if(n(a))return e.call(this,c,a,o,d);throw new Error(`Validation failed for type ${i}, data: ${a}`)},_decodeRaw(c,a,o){return r.call(this,c,a,o)}}),this}registerBcsType(t,e){return this.registerType(t,(r,n,i)=>{const s=i.map(c=>new q({name:String(c),write:(a,o)=>{const{name:d,params:u}=this.parseTypeName(c),g=this.getTypeInterface(d),m=u.reduce((y,w,b)=>Object.assign(y,{[w]:i[b]}),{});return g._encodeRaw.call(this,o,a,u,m)},read:()=>{throw new Error("Not implemented")}}));return e(...s).write(n,r),r},(r,n)=>{const i=n.map(s=>new q({name:String(s),write:(c,a)=>{throw new Error("Not implemented")},read:c=>{const{name:a,params:o}=this.parseTypeName(s),d=this.getTypeInterface(a),u=o.reduce((g,m,y)=>Object.assign(g,{[m]:n[y]}),{});return d._decodeRaw.call(this,c,o,u)}}));return e(...i).read(r)}),this}registerAddressType(t,e,r="hex"){switch(r){case"base64":return this.registerType(t,function(i,s){return le(s).reduce((c,a)=>c.write8(a),i)},function(i){return Ue(i.readBytes(e))});case"hex":return this.registerType(t,function(i,s){return rt(s).reduce((c,a)=>c.write8(a),i)},function(i){return Re(i.readBytes(e))});default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(t){let{name:e,params:r}=this.parseTypeName(t);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+e);return this.registerType(t,function(i,s,c,a){return i.writeVec(s,(o,d)=>{let u=c[0];if(!u)throw new Error(`Incorrect number of type parameters passed a to vector '${t}'`);let{name:g,params:m}=this.parseTypeName(u);if(this.hasType(g))return this.getTypeInterface(g)._encodeRaw.call(this,o,d,m,a);if(!(g in a))throw new Error(`Unable to find a matching type definition for ${g} in vector; make sure you passed a generic`);let{name:y,params:w}=this.parseTypeName(a[g]);return this.getTypeInterface(y)._encodeRaw.call(this,o,d,w,a)})},function(i,s,c){return i.readVec(a=>{let o=s[0];if(!o)throw new Error(`Incorrect number of type parameters passed to a vector '${t}'`);let{name:d,params:u}=this.parseTypeName(o);if(this.hasType(d))return this.getTypeInterface(d)._decodeRaw.call(this,a,u,c);if(!(d in c))throw new Error(`Unable to find a matching type definition for ${d} in vector; make sure you passed a generic`);let{name:g,params:m}=this.parseTypeName(c[d]);return this.getTypeInterface(g)._decodeRaw.call(this,a,m,c)})})}registerStructType(t,e){for(let c in e){let a=this.tempKey(),o=e[c];!Array.isArray(o)&&typeof o!="string"&&(e[c]=a,this.registerStructType(a,o))}let r=Object.freeze(e),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(t);return this.registerType(t,function(a,o,d,u){if(!o||o.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${o}`);if(d.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${d.length}`);for(let g of n){if(!(g in o))throw new Error(`Struct ${i} requires field ${g}:${r[g]}`);const{name:m,params:y}=this.parseTypeName(r[g]);if(!s.includes(m))this.getTypeInterface(m)._encodeRaw.call(this,a,o[g],y,u);else{const w=s.indexOf(m);let{name:b,params:f}=this.parseTypeName(d[w]);if(this.hasType(b)){this.getTypeInterface(b)._encodeRaw.call(this,a,o[g],f,u);continue}if(!(b in u))throw new Error(`Unable to find a matching type definition for ${b} in ${i}; make sure you passed a generic`);let{name:j,params:_}=this.parseTypeName(u[b]);this.getTypeInterface(j)._encodeRaw.call(this,a,o[g],_,u)}}return a},function(a,o,d){if(o.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${o.length}`);let u={};for(let g of n){const{name:m,params:y}=this.parseTypeName(r[g]);if(!s.includes(m))u[g]=this.getTypeInterface(m)._decodeRaw.call(this,a,y,d);else{const w=s.indexOf(m);let{name:b,params:f}=this.parseTypeName(o[w]);if(this.hasType(b)){u[g]=this.getTypeInterface(b)._decodeRaw.call(this,a,f,d);continue}if(!(b in d))throw new Error(`Unable to find a matching type definition for ${b} in ${i}; make sure you passed a generic`);let{name:j,params:_}=this.parseTypeName(d[b]);u[g]=this.getTypeInterface(j)._decodeRaw.call(this,a,_,d)}}return u})}registerEnumType(t,e){for(let c in e){let a=this.tempKey(),o=e[c];o!==null&&!Array.isArray(o)&&typeof o!="string"&&(e[c]=a,this.registerStructType(a,o))}let r=Object.freeze(e),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(t);return this.registerType(t,function(a,o,d,u){if(!o)throw new Error(`Unable to write enum "${i}", missing data.
Received: "${o}"`);if(typeof o!="object")throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".
Received: "${JSON.stringify(o)}"`);let g=Object.keys(o)[0];if(g===void 0)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let m=n.indexOf(g);if(m===-1)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${g}"`);let y=n[m],w=r[y];if(a.write8(m),w===null)return a;let b=s.indexOf(w),f=b===-1?w:d[b];{let{name:j,params:_}=this.parseTypeName(f);return this.getTypeInterface(j)._encodeRaw.call(this,a,o[g],_,u)}},function(a,o,d){let u=a.readULEB(),g=n[u],m=r[g];if(u===-1)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${u}"`);if(m===null)return{[g]:!0};let y=s.indexOf(m),w=y===-1?m:o[y];{let{name:b,params:f}=this.parseTypeName(w);return{[g]:this.getTypeInterface(b)._decodeRaw.call(this,a,f,d)}}})}getTypeInterface(t){let e=this.types.get(t);if(typeof e=="string"){let r=[];for(;typeof e=="string";){if(r.includes(e))throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${e}`);r.push(e),e=this.types.get(e)}}if(e===void 0)throw new Error(`Type ${t} is not registered`);return e}parseTypeName(t){if(Array.isArray(t)){let[a,...o]=t;return{name:a,params:o}}if(typeof t!="string")throw new Error(`Illegal type passed as a name of the type: ${t}`);let[e,r]=this.schema.genericSeparators||["<",">"],n=t.indexOf(e),i=Array.from(t).reverse().indexOf(r);if(n===-1&&i===-1)return{name:t,params:[]};if(n===-1||i===-1)throw new Error(`Unclosed generic in name '${t}'`);let s=t.slice(0,n),c=At(t.slice(n+1,t.length-i-1),this.schema.genericSeparators);return{name:s,params:c}}};let x=je;x.U8="u8";x.U16="u16";x.U32="u32";x.U64="u64";x.U128="u128";x.U256="u256";x.BOOL="bool";x.VECTOR="vector";x.ADDRESS="address";x.STRING="string";x.HEX="hex-string";x.BASE58="base58-string";x.BASE64="base64-string";function si(t){t.registerType(x.U8,function(e,r){return e.write8(r)},function(e){return e.read8()},e=>e<256),t.registerType(x.U16,function(e,r){return e.write16(r)},function(e){return e.read16()},e=>e<65536),t.registerType(x.U32,function(e,r){return e.write32(r)},function(e){return e.read32()},e=>e<=4294967296n),t.registerType(x.U64,function(e,r){return e.write64(r)},function(e){return e.read64()}),t.registerType(x.U128,function(e,r){return e.write128(r)},function(e){return e.read128()}),t.registerType(x.U256,function(e,r){return e.write256(r)},function(e){return e.read256()}),t.registerType(x.BOOL,function(e,r){return e.write8(r)},function(e){return e.read8().toString(10)==="1"}),t.registerType(x.STRING,function(e,r){return e.writeVec(Array.from(r),(n,i)=>n.write8(i.charCodeAt(0)))},function(e){return e.readVec(r=>r.read8()).map(r=>String.fromCharCode(Number(r))).join("")},e=>!0),t.registerType(x.HEX,function(e,r){return e.writeVec(Array.from(rt(r)),(n,i)=>n.write8(i))},function(e){let r=e.readVec(n=>n.read8());return Re(new Uint8Array(r))}),t.registerType(x.BASE58,function(e,r){return e.writeVec(Array.from(Et(r)),(n,i)=>n.write8(i))},function(e){let r=e.readVec(n=>n.read8());return $e(new Uint8Array(r))}),t.registerType(x.BASE64,function(e,r){return e.writeVec(Array.from(le(r)),(n,i)=>n.write8(i))},function(e){let r=e.readVec(n=>n.read8());return Ue(new Uint8Array(r))})}function ai(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:ii,addressEncoding:"hex"}}const xt=32;function oi(t){return ui(t)&&di(t)===xt}function ci(t){return t.includes("::")?$r(t):t}function $r(t){const[e,r]=t.split("::"),n=t.slice(e.length+r.length+4),i=n.includes("<")?n.slice(0,n.indexOf("<")):n,s=n.includes("<")?At(n.slice(n.indexOf("<")+1,n.lastIndexOf(">"))).map(c=>ci(c.trim())):[];return{address:N(e),module:r,name:i,typeParams:s}}function N(t,e=!1){let r=t.toLowerCase();return!e&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(xt*2,"0")}`}function Te(t,e=!1){return N(t,e)}function ui(t){return/^(0x|0X)?[a-fA-F0-9]+$/.test(t)&&t.length%2===0}function di(t){return/^(0x|0X)/.test(t)?(t.length-2)/2:t.length/2}BigInt(1e9);const Bt="0x1",Ur="0x2",pe=Te("0x6"),Ge=`${Ur}::sui::SUI`;Te("0x5");const li="object",fi="ID",hi="ascii",gi="String",pi="string",yi="String",mi="option",wi="Option",bi={address:Ur,module:li,name:fi},Si={address:Bt,module:hi,name:gi},Ti={address:Bt,module:pi,name:yi},vi={address:Bt,module:mi,name:wi},Pe=(t,e)=>t.address===e.address&&t.module===e.module&&t.name===e.name;function ki(t){var r;const e=(r=jt(t))==null?void 0:r.Struct;return(e==null?void 0:e.address)==="0x2"&&(e==null?void 0:e.module)==="tx_context"&&(e==null?void 0:e.name)==="TxContext"}function dt(t,e){if(!(typeof e>"u")&&typeof e!==t)throw new Error(`Expect ${e} to be ${t}, received ${typeof e}`)}const Ii=["Address","Bool","U8","U16","U32","U64","U128","U256"];function wt(t,e){if(typeof t=="string"&&Ii.includes(t)){if(t in["U8","U16","U32","U64","U128","U256"])dt("number",e);else if(t==="Bool")dt("boolean",e);else if(t==="Address"&&(dt("string",e),e&&!oi(e)))throw new Error("Invalid Sui Address");return t.toLowerCase()}else if(typeof t=="string")throw new Error(`Unknown pure normalized type ${JSON.stringify(t,null,2)}`);if("Vector"in t){if((e===void 0||typeof e=="string")&&t.Vector==="U8")return"string";if(e!==void 0&&!Array.isArray(e))throw new Error(`Expect ${e} to be a array, received ${typeof e}`);const r=wt(t.Vector,e?e[0]:void 0);return r===void 0?void 0:`vector<${r}>`}if("Struct"in t){if(Pe(t.Struct,Si))return"string";if(Pe(t.Struct,Ti))return"utf8string";if(Pe(t.Struct,bi))return"address";if(Pe(t.Struct,vi)){const r={Vector:t.Struct.typeArguments[0]};return wt(r,e)}}}const ji=/^vector<(.+)>$/,Ei=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ne{static parseFromStr(e,r=!1){if(e==="address")return{address:null};if(e==="bool")return{bool:null};if(e==="u8")return{u8:null};if(e==="u16")return{u16:null};if(e==="u32")return{u32:null};if(e==="u64")return{u64:null};if(e==="u128")return{u128:null};if(e==="u256")return{u256:null};if(e==="signer")return{signer:null};const n=e.match(ji);if(n)return{vector:ne.parseFromStr(n[1],r)};const i=e.match(Ei);if(i)return{struct:{address:r?N(i[1]):i[1],module:i[2],name:i[3],typeParams:i[5]===void 0?[]:ne.parseStructTypeArgs(i[5],r)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,r=!1){return At(e).map(n=>ne.parseFromStr(n,r))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${ne.tagToString(e.vector)}>`;if("struct"in e){const r=e.struct,n=r.typeParams.map(ne.tagToString).join(", ");return`${r.address}::${r.module}::${r.name}${n?`<${n}>`:""}`}throw new Error("Invalid TypeTag")}}const A=new x({...ai(),types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function Rr(t){return l.u64({name:"unsafe_u64",...t}).transform({input:e=>e,output:e=>Number(e)})}function Oi(t){return l.enum("Option",{None:null,Some:t})}function Ct(t){return t.transform({input:e=>({[e.kind]:e}),output:e=>{const r=Object.keys(e)[0];return{kind:r,...e[r]}}})}const Z=l.bytes(xt).transform({input:t=>typeof t=="string"?rt(N(t)):t,output:t=>N(Re(t))}),$t=l.vector(l.u8()).transform({name:"ObjectDigest",input:t=>Et(t),output:t=>$e(new Uint8Array(t))}),_e=l.struct("SuiObjectRef",{objectId:Z,version:l.u64(),digest:$t}),Ut=l.struct("SharedObjectRef",{objectId:Z,initialSharedVersion:l.u64(),mutable:l.bool()}),Ye=l.enum("ObjectArg",{ImmOrOwned:_e,Shared:Ut,Receiving:_e}),Rt=l.enum("CallArg",{Pure:l.vector(l.u8()),Object:Ye,ObjVec:l.vector(Ye)}),ve=l.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:l.lazy(()=>ve),struct:l.lazy(()=>zt),u16:null,u32:null,u256:null}),J=Ct(l.enum("Argument",{GasCoin:null,Input:l.struct("Input",{index:l.u16()}),Result:l.struct("Result",{index:l.u16()}),NestedResult:l.struct("NestedResult",{index:l.u16(),resultIndex:l.u16()})})),Pt=l.struct("ProgrammableMoveCall",{package:Z,module:l.string(),function:l.string(),type_arguments:l.vector(ve),arguments:l.vector(J)}).transform({input:t=>{const[e,r,n]=t.target.split("::"),i=t.typeArguments.map(s=>ne.parseFromStr(s,!0));return{package:N(e),module:r,function:n,type_arguments:i,arguments:t.arguments}},output:t=>({target:[t.package,t.module,t.function].join("::"),arguments:t.arguments,typeArguments:t.type_arguments.map(ne.tagToString)})}),Mt=Ct(l.enum("Transaction",{MoveCall:Pt,TransferObjects:l.struct("TransferObjects",{objects:l.vector(J),address:J}),SplitCoins:l.struct("SplitCoins",{coin:J,amounts:l.vector(J)}),MergeCoins:l.struct("MergeCoins",{destination:J,sources:l.vector(J)}),Publish:l.struct("Publish",{modules:l.vector(l.vector(l.u8())),dependencies:l.vector(Z)}),MakeMoveVec:l.struct("MakeMoveVec",{type:Oi(ve),objects:l.vector(J)}),Upgrade:l.struct("Upgrade",{modules:l.vector(l.vector(l.u8())),dependencies:l.vector(Z),packageId:Z,ticket:J})})),Nt=l.struct("ProgrammableTransaction",{inputs:l.vector(Rt),transactions:l.vector(Mt)}),Dt=l.enum("TransactionKind",{ProgrammableTransaction:Nt,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Vt=l.enum("TransactionExpiration",{None:null,Epoch:Rr()}),zt=l.struct("StructTag",{address:Z,module:l.string(),name:l.string(),typeParams:l.vector(ve)}),Ft=l.struct("GasData",{payment:l.vector(_e),owner:Z,price:l.u64(),budget:l.u64()}),Gt=l.struct("TransactionDataV1",{kind:Dt,sender:Z,gasData:Ft,expiration:Vt}),Lt=l.enum("TransactionData",{V1:Gt}),Ai=l.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),_i=l.enum("IntentVersion",{V0:null}),xi=l.enum("AppId",{Sui:null}),Bi=l.struct("Intent",{scope:Ai,version:_i,appId:xi}),Ci=l.generic(["T"],t=>l.struct("IntentMessage<T>",{intent:Bi,value:t})),Wt=l.enum("CompressedSignature",{ED25519:l.fixedArray(64,l.u8()),Secp256k1:l.fixedArray(64,l.u8()),Secp256r1:l.fixedArray(64,l.u8()),ZkLogin:l.vector(l.u8())}),Kt=l.enum("PublicKey",{ED25519:l.fixedArray(32,l.u8()),Secp256k1:l.fixedArray(33,l.u8()),Secp256r1:l.fixedArray(33,l.u8()),ZkLogin:l.vector(l.u8())}),Jt=l.struct("MultiSigPkMap",{pubKey:Kt,weight:l.u8()}),Ht=l.struct("MultiSigPublicKey",{pk_map:l.vector(Jt),threshold:l.u16()}),Pr=l.struct("MultiSig",{sigs:l.vector(Wt),bitmap:l.u16(),multisig_pk:Ht}),$i=l.vector(l.u8()).transform({input:t=>typeof t=="string"?le(t):t,output:t=>Ue(new Uint8Array(t))}),Mr=l.struct("SenderSignedTransaction",{intentMessage:Ci(Lt),txSignatures:l.vector($i)}),Nr=l.vector(Mr,{name:"SenderSignedData"}),P={...l,U8:l.u8(),U16:l.u16(),U32:l.u32(),U64:l.u64(),U128:l.u128(),U256:l.u256(),ULEB128:l.uleb128(),Bool:l.bool(),String:l.string(),Address:Z,Argument:J,CallArg:Rt,CompressedSignature:Wt,GasData:Ft,MultiSig:Pr,MultiSigPkMap:Jt,MultiSigPublicKey:Ht,ObjectArg:Ye,ObjectDigest:$t,ProgrammableMoveCall:Pt,ProgrammableTransaction:Nt,PublicKey:Kt,SenderSignedData:Nr,SenderSignedTransaction:Mr,SharedObjectRef:Ut,StructTag:zt,SuiObjectRef:_e,Transaction:Mt,TransactionData:Lt,TransactionDataV1:Gt,TransactionExpiration:Vt,TransactionKind:Dt,TypeTag:ve,ser:A.ser.bind(A),de:A.de.bind(A),getTypeInterface:A.getTypeInterface.bind(A),hasType:A.hasType.bind(A),parseTypeName:A.parseTypeName.bind(A),registerAddressType:A.registerAddressType.bind(A),registerAlias:A.registerAlias.bind(A),registerBcsType:A.registerBcsType.bind(A),registerEnumType:A.registerEnumType.bind(A),registerStructType:A.registerStructType.bind(A),registerType:A.registerType.bind(A),types:A.types};A.registerBcsType("utf8string",()=>l.string({name:"utf8string"}));A.registerBcsType("unsafe_u64",()=>Rr());A.registerBcsType("enumKind",t=>Ct(t));[Z,J,Rt,Wt,Ft,Pr,Jt,Ht,Ye,$t,Pt,Nt,Kt,Nr,Ut,zt,_e,Mt,Lt,Gt,Vt,Dt,ve].forEach(t=>{A.registerBcsType(t.name,()=>t)});const Ui=$([p({ImmOrOwned:de}),p({Shared:p({objectId:h(),initialSharedVersion:$([ee(),h()]),mutable:D()})}),p({Receiving:de})]),Qe=p({Pure:I(ee())}),bt=p({Object:Ui}),et=$([Qe,bt]);function Ri(t,e){return{Pure:Array.from(t instanceof Uint8Array?t:_t(t)?t.toBytes():P.ser(e,t,{maxSize:1/0}).toBytes())}}const z={Pure:Ri,ObjectRef({objectId:t,digest:e,version:r}){return{Object:{ImmOrOwned:{digest:e,version:r,objectId:N(t)}}}},SharedObjectRef({objectId:t,mutable:e,initialSharedVersion:r}){return{Object:{Shared:{mutable:e,initialSharedVersion:r,objectId:N(t)}}}},ReceivingRef({objectId:t,digest:e,version:r}){return{Object:{Receiving:{digest:e,version:r,objectId:N(t)}}}}};function ur(t){return typeof t=="string"?N(t):"ImmOrOwned"in t.Object?N(t.Object.ImmOrOwned.objectId):"Receiving"in t.Object?N(t.Object.Receiving.objectId):N(t.Object.Shared.objectId)}function Pi(t){return typeof t=="object"&&"Object"in t&&"Shared"in t.Object?t.Object.Shared:void 0}function Mi(t){var e;return((e=Pi(t))==null?void 0:e.mutable)??!1}function V(t,e){return mr(t,e)}const Ni=t=>$([p({None:$([T(!0),T(null)])}),p({Some:t})]),xe=$([p({kind:T("Input"),index:ee(),value:S(yt()),type:S(T("object"))}),p({kind:T("Input"),index:ee(),value:S(yt()),type:T("pure")})]),Di=[xe,p({kind:T("GasCoin")}),p({kind:T("Result"),index:ee()}),p({kind:T("NestedResult"),index:ee(),resultIndex:ee()})],se=$([...Di]),Dr=p({kind:T("MoveCall"),target:G("target",h().validator),typeArguments:I(h()),arguments:I(se)}),Vr=p({kind:T("TransferObjects"),objects:I(se),address:se}),zr=p({kind:T("SplitCoins"),coin:se,amounts:I(se)}),Fr=p({kind:T("MergeCoins"),destination:se,sources:I(se)}),Gr=p({kind:T("MakeMoveVec"),type:S(Ni(Y(h(),Tr()))),objects:I(se)}),Lr=p({kind:T("Publish"),modules:I(I(ee())),dependencies:I(h())}),Wr=p({kind:T("Upgrade"),modules:I(I(ee())),dependencies:I(h()),packageId:h(),ticket:se}),Vi=[Dr,Vr,zr,Fr,Lr,Wr,Gr],zi=$([...Vi]),he={MoveCall(t){return V({kind:"MoveCall",target:t.target,arguments:t.arguments??[],typeArguments:t.typeArguments??[]},Dr)},TransferObjects(t,e){return e.kind==="Input"&&e.type==="pure"&&typeof e.value!="object"&&(e.value=z.Pure(P.Address.serialize(e.value))),V({kind:"TransferObjects",objects:t,address:e},Vr)},SplitCoins(t,e){return e.forEach(r=>{r.kind==="Input"&&r.type==="pure"&&typeof r.value!="object"&&(r.value=z.Pure(P.U64.serialize(r.value)))}),V({kind:"SplitCoins",coin:t,amounts:e},zr)},MergeCoins(t,e){return V({kind:"MergeCoins",destination:t,sources:e},Fr)},Publish({modules:t,dependencies:e}){return V({kind:"Publish",modules:t.map(r=>typeof r=="string"?Array.from(le(r)):r),dependencies:e.map(r=>Te(r))},Lr)},Upgrade({modules:t,dependencies:e,packageId:r,ticket:n}){return V({kind:"Upgrade",modules:t.map(i=>typeof i=="string"?Array.from(le(i)):i),dependencies:e.map(i=>Te(i)),packageId:r,ticket:n},Wr)},MakeMoveVec({type:t,objects:e}){return V({kind:"MakeMoveVec",type:t?{Some:ne.parseFromStr(t)}:{None:null},objects:e},Gr)}};function Fi(t){function e(r,n){return t(r,n)}return e.u8=r=>t(P.U8.serialize(r)),e.u16=r=>t(P.U16.serialize(r)),e.u32=r=>t(P.U32.serialize(r)),e.u64=r=>t(P.U64.serialize(r)),e.u128=r=>t(P.U128.serialize(r)),e.u256=r=>t(P.U256.serialize(r)),e.bool=r=>t(P.Bool.serialize(r)),e.string=r=>t(P.String.serialize(r)),e.address=r=>t(P.Address.serialize(r)),e.id=e.address,e}function Gi(t,e){const r=Array.from(`${t}::`).map(i=>i.charCodeAt(0)),n=new Uint8Array(r.length+e.length);return n.set(r),n.set(e,r.length),en(n,{dkLen:32})}const Li=S(B($([p({Epoch:ee()}),p({None:$([T(!0),T(null)])})]))),dr=G("StringEncodedBigint",t=>{if(!["string","number","bigint"].includes(typeof t))return!1;try{return BigInt(t),!0}catch{return!1}}),Wi=p({budget:S(dr),price:S(dr),payment:S(I(de)),owner:S(h())}),Me=p({version:T(1),sender:S(h()),expiration:Li,gasConfig:Wi,inputs:I(xe),transactions:I(zi)});function lr(t){return N(t).replace("0x","")}class ie{constructor(e){this.version=1,this.sender=e==null?void 0:e.sender,this.expiration=e==null?void 0:e.expiration,this.gasConfig=(e==null?void 0:e.gasConfig)??{},this.inputs=(e==null?void 0:e.inputs)??[],this.transactions=(e==null?void 0:e.transactions)??[]}static fromKindBytes(e){const r=P.TransactionKind.parse(e),n="ProgrammableTransaction"in r?r.ProgrammableTransaction:null;if(!n)throw new Error("Unable to deserialize from bytes.");const i=V({version:1,gasConfig:{},inputs:n.inputs.map((s,c)=>V({kind:"Input",value:s,index:c,type:F(s,Qe)?"pure":"object"},xe)),transactions:n.transactions},Me);return ie.restore(i)}static fromBytes(e){var c;const r=P.TransactionData.parse(e),n=r==null?void 0:r.V1,i="ProgrammableTransaction"in n.kind?(c=n==null?void 0:n.kind)==null?void 0:c.ProgrammableTransaction:null;if(!n||!i)throw new Error("Unable to deserialize from bytes.");const s=V({version:1,sender:n.sender,expiration:n.expiration,gasConfig:n.gasData,inputs:i.inputs.map((a,o)=>V({kind:"Input",value:a,index:o,type:F(a,Qe)?"pure":"object"},xe)),transactions:i.transactions},Me);return ie.restore(s)}static restore(e){pt(e,Me);const r=new ie;return Object.assign(r,e),r}static getDigestFromBytes(e){const r=Gi("TransactionData",e);return $e(r)}build({maxSizeBytes:e=1/0,overrides:r,onlyTransactionKind:n}={}){const i=this.inputs.map(u=>(pt(u.value,et),u.value)),s={ProgrammableTransaction:{inputs:i,transactions:this.transactions}};if(n)return P.TransactionKind.serialize(s,{maxSize:e}).toBytes();const c=(r==null?void 0:r.expiration)??this.expiration,a=(r==null?void 0:r.sender)??this.sender,o={...this.gasConfig,...r==null?void 0:r.gasConfig};if(!a)throw new Error("Missing transaction sender");if(!o.budget)throw new Error("Missing gas budget");if(!o.payment)throw new Error("Missing gas payment");if(!o.price)throw new Error("Missing gas price");const d={sender:lr(a),expiration:c||{None:!0},gasData:{payment:o.payment,owner:lr(this.gasConfig.owner??a),price:BigInt(o.price),budget:BigInt(o.budget)},kind:{ProgrammableTransaction:{inputs:i,transactions:this.transactions}}};return P.TransactionData.serialize({V1:d},{maxSize:e}).toBytes()}getDigest(){const e=this.build({onlyTransactionKind:!1});return ie.getDigestFromBytes(e)}snapshot(){return V(this,Me)}}var Xt=(t,e,r)=>{if(!e.has(t))throw TypeError("Cannot "+r)},O=(t,e,r)=>(Xt(t,e,"read from private field"),r?r.call(t):e.get(t)),re=(t,e,r)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,r)},Ne=(t,e,r,n)=>(Xt(t,e,"write to private field"),e.set(t,r),r),M=(t,e,r)=>(Xt(t,e,"access private method"),r),v,Ee,Le,Oe,We,fe,me,qt,Kr,Zt,Jr,Yt,Hr,Qt,Xr,Ke,St;const Ki={maxPureArgumentSize:16*1024,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:128*1024};function Ji(t){const e={kind:"Result",index:t},r=[],n=i=>r[i]??(r[i]={kind:"NestedResult",index:t,resultIndex:i});return new Proxy(e,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,s){if(s in i)return Reflect.get(i,s);if(s===Symbol.iterator)return function*(){let a=0;for(;;)yield n(a),a++};if(typeof s=="symbol")return;const c=parseInt(s,10);if(!(Number.isNaN(c)||c<0))return n(c)}})}function Hi(t){const e=jt(t);return e?e.Struct.address==="0x2"&&e.Struct.module==="transfer"&&e.Struct.name==="Receiving":!1}function Be(t){if(!t.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return t.client}const Xi=Symbol.for("@mysten/transaction"),lt={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},qi=1000n,Zi=50,Yi=(t,e)=>Array.from({length:Math.ceil(t.length/e)},(r,n)=>t.slice(n*e,n*e+e)),Tt=class{constructor(t){re(this,Ee),re(this,Oe),re(this,fe),re(this,qt),re(this,Zt),re(this,Yt),re(this,Qt),re(this,Ke),re(this,v,void 0),Ne(this,v,new ie(t?t.blockData:void 0))}static fromKind(t){const e=new Tt;return Ne(e,v,ie.fromKindBytes(typeof t=="string"?le(t):t)),e}static from(t){const e=new Tt;return typeof t!="string"||!t.startsWith("{")?Ne(e,v,ie.fromBytes(typeof t=="string"?le(t):t)):Ne(e,v,ie.restore(JSON.parse(t))),e}setSender(t){O(this,v).sender=t}setSenderIfNotSet(t){O(this,v).sender||(O(this,v).sender=t)}setExpiration(t){O(this,v).expiration=t}setGasPrice(t){O(this,v).gasConfig.price=String(t)}setGasBudget(t){O(this,v).gasConfig.budget=String(t)}setGasOwner(t){O(this,v).gasConfig.owner=t}setGasPayment(t){O(this,v).gasConfig.payment=t.map(e=>wr(e,de))}get blockData(){return O(this,v).snapshot()}get[Xi](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Fi((t,e)=>_t(t)?M(this,Ee,Le).call(this,"pure",{Pure:Array.from(t.toBytes())}):M(this,Ee,Le).call(this,"pure",t instanceof Uint8Array?z.Pure(t):e?z.Pure(t,e):t))}),this.pure}get gas(){return{kind:"GasCoin"}}object(t){if(typeof t=="object"&&"kind"in t)return t;const e=ur(t),r=O(this,v).inputs.find(n=>n.type==="object"&&e===ur(n.value));return r&&F(r.value,bt)&&"Shared"in r.value.Object&&F(t,bt)&&"Shared"in t.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||t.Object.Shared.mutable),r??M(this,Ee,Le).call(this,"object",typeof t=="string"?N(t):t)}objectRef(...t){return this.object(z.ObjectRef(...t))}receivingRef(...t){return this.object(z.ReceivingRef(...t))}sharedObjectRef(...t){return this.object(z.SharedObjectRef(...t))}add(t){const e=O(this,v).transactions.push(t);return Ji(e-1)}splitCoins(t,e){return this.add(he.SplitCoins(typeof t=="string"?this.object(t):t,e.map(r=>typeof r=="number"||typeof r=="bigint"||typeof r=="string"?this.pure.u64(r):M(this,Oe,We).call(this,r))))}mergeCoins(t,e){return this.add(he.MergeCoins(typeof t=="string"?this.object(t):t,e.map(r=>typeof r=="string"?this.object(r):r)))}publish({modules:t,dependencies:e}){return this.add(he.Publish({modules:t,dependencies:e}))}upgrade({modules:t,dependencies:e,packageId:r,ticket:n}){return this.add(he.Upgrade({modules:t,dependencies:e,packageId:r,ticket:typeof n=="string"?this.object(n):n}))}moveCall({arguments:t,typeArguments:e,target:r}){return this.add(he.MoveCall({arguments:t==null?void 0:t.map(n=>M(this,Oe,We).call(this,n)),typeArguments:e,target:r}))}transferObjects(t,e){return this.add(he.TransferObjects(t.map(r=>typeof r=="string"?this.object(r):r),typeof e=="string"?this.pure.address(e):M(this,Oe,We).call(this,e)))}makeMoveVec({type:t,objects:e}){return this.add(he.MakeMoveVec({type:t,objects:e.map(r=>typeof r=="string"?this.object(r):r)}))}serialize(){return JSON.stringify(O(this,v).snapshot())}async sign(t){const{signer:e,...r}=t,n=await this.build(r);return e.signTransactionBlock(n)}async build(t={}){return await M(this,Ke,St).call(this,t),O(this,v).build({maxSizeBytes:M(this,fe,me).call(this,"maxTxSizeBytes",t),onlyTransactionKind:t.onlyTransactionKind})}async getDigest(t={}){return await M(this,Ke,St).call(this,t),O(this,v).getDigest()}};let ue=Tt;v=new WeakMap;Ee=new WeakSet;Le=function(t,e){const r=O(this,v).inputs.length,n=V({kind:"Input",value:typeof e=="bigint"?String(e):e,index:r,type:t},xe);return O(this,v).inputs.push(n),n};Oe=new WeakSet;We=function(t){return _t(t)?this.pure(t):t};fe=new WeakSet;me=function(t,{protocolConfig:e,limits:r}){if(r&&typeof r[t]=="number")return r[t];if(!e)return Ki[t];const n=e==null?void 0:e.attributes[lt[t]];if(!n)throw new Error(`Missing expected protocol config: "${lt[t]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${lt[t]}"`);return Number(i)};qt=new WeakSet;Kr=function(t){const e=M(this,fe,me).call(this,"maxPureArgumentSize",t);O(this,v).inputs.forEach((r,n)=>{if(F(r.value,Qe)&&r.value.Pure.length>e)throw new Error(`Input at index ${n} is too large, max pure input size is ${e} bytes, got ${r.value.Pure.length} bytes`)})};Zt=new WeakSet;Jr=async function(t){if(O(this,v).gasConfig.payment){const i=M(this,fe,me).call(this,"maxGasObjects",t);if(O(this,v).gasConfig.payment.length>i)throw new Error(`Payment objects exceed maximum amount: ${i}`)}if(t.onlyTransactionKind||O(this,v).gasConfig.payment)return;const e=O(this,v).gasConfig.owner??O(this,v).sender,n=(await Be(t).getCoins({owner:e,coinType:Ge})).data.filter(i=>!O(this,v).inputs.find(c=>F(c.value,et)&&"Object"in c.value&&"ImmOrOwned"in c.value.Object?i.coinObjectId===c.value.Object.ImmOrOwned.objectId:!1)).slice(0,M(this,fe,me).call(this,"maxGasObjects",t)-1).map(i=>({objectId:i.coinObjectId,digest:i.digest,version:i.version}));if(!n.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(n)};Yt=new WeakSet;Hr=async function(t){t.onlyTransactionKind||O(this,v).gasConfig.price||this.setGasPrice(await Be(t).getReferenceGasPrice())};Qt=new WeakSet;Xr=async function(t){const{inputs:e,transactions:r}=O(this,v),n=[],i=[];if(e.forEach(s=>{if(s.type==="object"&&typeof s.value=="string"){i.push({id:N(s.value),input:s});return}}),r.forEach(s=>{if(s.kind==="MoveCall"&&s.arguments.some(a=>a.kind==="Input"&&!F(e[a.index].value,et))&&n.push(s),s.kind==="SplitCoins"&&s.amounts.forEach(c=>{if(c.kind==="Input"){const a=e[c.index];typeof a.value!="object"&&(a.value=z.Pure(P.U64.serialize(a.value)))}}),s.kind==="TransferObjects"&&s.address.kind==="Input"){const c=e[s.address.index];typeof c.value!="object"&&(c.value=z.Pure(P.Address.serialize(c.value)))}}),n.length&&await Promise.all(n.map(async s=>{const[c,a,o]=s.target.split("::"),d=await Be(t).getNormalizedMoveFunction({package:Te(c),module:a,function:o}),g=d.parameters.length>0&&ki(d.parameters.at(-1))?d.parameters.slice(0,d.parameters.length-1):d.parameters;if(g.length!==s.arguments.length)throw new Error("Incorrect number of arguments.");g.forEach((m,y)=>{const w=s.arguments[y];if(w.kind!=="Input")return;const b=e[w.index];if(F(b.value,et))return;const f=b.value,j=wt(m,f);if(j){b.value=z.Pure(f,j);return}if(jt(m)!=null||typeof m=="object"&&"TypeParameter"in m){if(typeof f!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(f,null,2)}`);i.push({id:f,input:b,normalizedType:m});return}throw new Error(`Unknown call arg type ${JSON.stringify(m,null,2)} for value ${JSON.stringify(f,null,2)}`)})})),i.length){const s=[...new Set(i.map(({id:u})=>u))],c=Yi(s,Zi),a=(await Promise.all(c.map(u=>Be(t).multiGetObjects({ids:u,options:{showOwner:!0}})))).flat();let o=new Map(s.map((u,g)=>[u,a[g]]));const d=Array.from(o).filter(([u,g])=>g.error).map(([u,g])=>u);if(d.length)throw new Error(`The following input objects are invalid: ${d.join(", ")}`);i.forEach(({id:u,input:g,normalizedType:m})=>{var f;const y=o.get(u),w=(f=y.data)==null?void 0:f.owner,b=w&&typeof w=="object"&&"Shared"in w?w.Shared.initial_shared_version:void 0;if(b){const j=m!=null&&mt(m)==null&&Er(m)==null,_=Mi(g.value)||j||m!=null&&mt(m)!=null;g.value=z.SharedObjectRef({objectId:u,initialSharedVersion:b,mutable:_})}else m&&Hi(m)?g.value=z.ReceivingRef(cr(y)):g.value=z.ObjectRef(cr(y))})}};Ke=new WeakSet;St=async function(t){if(!t.onlyTransactionKind&&!O(this,v).sender)throw new Error("Missing transaction sender");if(!t.protocolConfig&&!t.limits&&t.client&&(t.protocolConfig=await t.client.getProtocolConfig()),await Promise.all([M(this,Yt,Hr).call(this,t),M(this,Qt,Xr).call(this,t)]),!t.onlyTransactionKind&&(await M(this,Zt,Jr).call(this,t),!O(this,v).gasConfig.budget)){const e=await Be(t).dryRunTransactionBlock({transactionBlock:O(this,v).build({maxSizeBytes:M(this,fe,me).call(this,"maxTxSizeBytes",t),overrides:{gasConfig:{budget:String(M(this,fe,me).call(this,"maxTxGas",t)),payment:[]}}})});if(e.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${e.effects.status.error}`,{cause:e});const r=qi*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(e.effects.gasUsed.computationCost)+r,i=n+BigInt(e.effects.gasUsed.storageCost)-BigInt(e.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}M(this,qt,Kr).call(this,t)};const fr=async(t,e,r)=>{var c,a,o;if(!ft(r))throw new Error(`Invalid Sui type: ${r}`);const n=await tt(t,e);if(!n)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${e}`);const i=(a=(c=n.token_registry.fields)==null?void 0:c.id)==null?void 0:a.id;if(!i)throw new Error("Unable to fetch token registry object ID");const s=tn((o=n.token_registry)==null?void 0:o.type);if(!s)throw new Error("Unable to fetch token registry package ID");return t.getDynamicFieldObject({parentId:i,name:{type:`${s}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},Je=async(t,e,r,n)=>{var u,g,m,y;const i=await tt(t,e);if(!i)throw new Error("Unable to fetch object fields from token bridge state");const s=(g=(u=i.token_registry)==null?void 0:u.fields)==null?void 0:g.coin_types,c=(y=(m=s==null?void 0:s.fields)==null?void 0:m.id)==null?void 0:y.id;if(!c)throw new Error("Unable to fetch coin types");const a=hr(s==null?void 0:s.type);if(!a)throw new Error("Unable to get key type");const o=await t.getDynamicFieldObject({parentId:c,name:{type:a,value:{addr:[...r],chain:n}}});if(o.error){if(o.error.code==="dynamicFieldNotFound")return null;throw new Error(`Unexpected getDynamicFieldObject response ${o.error}`)}const d=gt(o);if(!d)return null;if(!Ve(d))throw new Error("What?");return"value"in d?ke(d.value):null};class er{constructor(e,r,n,i){C(this,"network");C(this,"chain");C(this,"provider");C(this,"contracts");C(this,"coreBridgeObjectId");C(this,"tokenBridgeObjectId");C(this,"chainId");this.network=e,this.chain=r,this.provider=n,this.contracts=i,this.chainId=rn.get(e,r);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);const c=this.contracts.coreBridge;if(!c)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=c}static async fromRpc(e,r){const[n,i]=await Q.chainFromRpc(e),s=r[i];if(s.network!==n)throw new Error(`Network mismatch: ${s.network} != ${n}`);return new er(n,i,e,s.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let r=e.getCoinType();if(!ft(r))throw new Error(`Invalid Sui type: ${r}`);const n=await fr(this.provider,this.tokenBridgeObjectId,r),i=gt(n);if(!i)throw nt(r);if(!Ve(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const s=i.value;if(!H(s))throw new Error("Expected fields to be a MoveStruct");const c=ke(s.type);if(r=ke(r),c.includes(`wrapped_asset::WrappedAsset<${r}>`)){const a=s.fields.info;if(!H(a))throw new Error("Expected fields to be a MoveStruct");const o=a.fields.token_address;if(!H(o))throw new Error("Expected fields to be a MoveStruct");if(!Ve(o.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in o.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const d=o.fields.value;if(!H(d))throw new Error("Expected fields to be a MoveStruct");const u=new Uint8Array(d.fields.data);return{chain:nn(Number(a.fields.token_chain)),address:new nr(u)}}throw nt(r)}async getTokenUniversalAddress(e){let r=e.getCoinType();if(!ft(r))throw new Error(`Invalid Sui type: ${r}`);const n=await fr(this.provider,this.tokenBridgeObjectId,r),i=gt(n);if(!i)throw new Error(`Token of type ${r} has not been registered with the token bridge. Has it been attested?`);if(!Ve(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const s=i.value;if(!H(s))throw new Error("Expected fields to be a MoveStruct");const c=ke(s.type);if(r=ke(r),c.includes(`native_asset::NativeAsset<${r}>`)){const a=s.fields.token_address;if(!H(a))throw new Error("Expected fields to be a MoveStruct");if(!("value"in a.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const o=a.fields.value;if(!H(o))throw new Error("Expected fields to be a MoveStruct");const d=new Uint8Array(o.fields.data);return new nr(d)}throw new Error(`Token of type ${r} is not a native asset`)}async getTokenNativeAddress(e,r){const n=await Je(this.provider,this.tokenBridgeObjectId,r.toUint8Array(),ce(e));if(!n)throw new Error(`Token ${r.toString()} not found in token registry`);return new ge(n)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if(oe(e.address))throw new Error("Token Address required, 'native' literal not supported");const r=await Je(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),ce(e.chain));if(!r)throw nt(sn(e));return ir(this.chain,r)}async isTransferCompleted(e){var a,o,d,u,g,m,y,w;const r=await tt(this.provider,this.tokenBridgeObjectId);if(!r)throw new Error("Unable to fetch object fields from token bridge state");const n=(o=(a=r.consumed_vaas)==null?void 0:a.fields)==null?void 0:o.hashes,i=hr((u=(d=n==null?void 0:n.fields)==null?void 0:d.items)==null?void 0:u.type);if(!i)throw new Error("Unable to get key type");const s=(w=(y=(m=(g=n==null?void 0:n.fields)==null?void 0:g.items)==null?void 0:m.fields)==null?void 0:y.id)==null?void 0:w.id;if(!s)throw new Error("Unable to fetch consumed VAAs table");const c=await this.provider.getDynamicFieldObject({parentId:s,name:{type:i,value:{data:[...an(e.hash)]}}});if(!c.error)return!0;if(c.error.code==="dynamicFieldNotFound")return!1;throw new Error(`Unexpected getDynamicFieldObject response ${c.error}`)}async*createAttestation(e){const r=0n,n=0n,i=e.toString(),s=await this.provider.getCoinMetadata({coinType:i});if(s===null||s.id===null)throw new Error(`Coin metadata ID for type ${i} not found`);const[c,a]=await this.getPackageIds(),o=new ue,[d]=o.splitCoins(o.gas,[o.pure(r)]),[u]=o.moveCall({target:`${a}::attest_token::attest_token`,arguments:[o.object(this.tokenBridgeObjectId),o.object(s.id),o.pure(n)],typeArguments:[i]});o.moveCall({target:`${c}::publish_message::publish_message`,arguments:[o.object(this.coreBridgeObjectId),d,u,o.object(pe)]}),yield this.createUnsignedTx(o,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(e,r){const[n,i]=await this.getPackageIds(),s=r.toString(),c=Math.min(e.payload.decimals,8),a=await this.getCoinBuildOutput(n,i,c),o=await ln(a,s);yield this.createUnsignedTx(o,"Sui.TokenBridge.PrepareCreateWrapped");let d="",u="",g="",m="",y="",w=!1;for(;!w;){await new Promise(E=>setTimeout(E,500));const U=await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3});for(const E of U.data)if("objectChanges"in E){for(const k of E.objectChanges)fn(k)&&k.packageId!==void 0?d=k.packageId:it(k)&&k.objectType.includes("WrappedAssetSetup")?(u=k.objectId,y=k.objectType.split(", ")[1].replace(">","")):it(k)&&k.objectType.includes("UpgradeCap")?g=k.objectId:it(k)&&k.objectType.includes("CoinMetadata")&&(m=k.objectId);if(d!==""&&u!==""&&g!==""&&m!==""){w=!0;break}else d="",u="",g="",m=""}}const b=on(d),f=new ue,[j]=f.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[f.object(this.coreBridgeObjectId),f.pure(ze(ht(e))),f.object(pe)]}),[_]=f.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[f.object(this.tokenBridgeObjectId),j]});f.moveCall({target:`${i}::create_wrapped::complete_registration`,arguments:[f.object(this.tokenBridgeObjectId),f.object(m),f.object(u),f.object(g),_],typeArguments:[b,y]}),yield this.createUnsignedTx(f,"Sui.TokenBridge.SubmitAttestation")}async*transfer(e,r,n,i,s){const c=0n,a=0n,d=e.toString(),u=(oe(n)?Ge:n).toString(),g=await Q.getCoins(this.provider,e,u),[m,...y]=g.filter(E=>pr(E.coinType,u));if(m===void 0)throw new Error(`Coins array doesn't contain any coins of type ${u}`);const[w,b]=await this.getPackageIds(),f=new ue,[j]=(()=>{if(u===Ge)return f.splitCoins(f.gas,[f.pure(i)]);{const E=f.object(m.coinObjectId);return y.length&&f.mergeCoins(E,y.map(k=>f.object(k.coinObjectId))),f.splitCoins(E,[f.pure(i)])}})(),[_]=f.splitCoins(f.gas,[f.pure(c)]),[U]=f.moveCall({target:`${b}::state::verified_asset`,arguments:[f.object(this.tokenBridgeObjectId)],typeArguments:[u]});if(s){if(!d)throw new Error("senderAddress is required for transfer with payload");let E=!1;const k=await(async()=>{const rr=await hn(this.provider,w,d);if(rr!==null)return f.object(rr);{const[qr]=f.moveCall({target:`${w}::emitter::new`,arguments:[f.object(this.coreBridgeObjectId)]});return E=!0,qr}})(),[R,K]=f.moveCall({target:`${b}::transfer_tokens_with_payload::prepare_transfer`,arguments:[k,U,j,f.pure(ce(r.chain)),f.pure(r.address.toUint8Array()),f.pure([...s]),f.pure(0)],typeArguments:[u]});f.moveCall({target:`${b}::coin_utils::return_nonzero`,arguments:[K],typeArguments:[u]});const[we]=f.moveCall({target:`${b}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[f.object(this.tokenBridgeObjectId),R],typeArguments:[u]});f.moveCall({target:`${w}::publish_message::publish_message`,arguments:[f.object(this.coreBridgeObjectId),_,we,f.object(pe)]}),E&&f.transferObjects([k],f.pure(d)),yield this.createUnsignedTx(f,"Sui.TokenBridge.TransferWithPayload")}else{const[E,k]=f.moveCall({target:`${b}::transfer_tokens::prepare_transfer`,arguments:[U,j,f.pure(ce(r.chain)),f.pure(ze(r.address.toUint8Array())),f.pure(a),f.pure(0)],typeArguments:[u]});f.moveCall({target:`${b}::coin_utils::return_nonzero`,arguments:[k],typeArguments:[u]});const[R]=f.moveCall({target:`${b}::transfer_tokens::transfer_tokens`,arguments:[f.object(this.tokenBridgeObjectId),E],typeArguments:[u]});f.moveCall({target:`${w}::publish_message::publish_message`,arguments:[f.object(this.coreBridgeObjectId),_,R,f.object(pe)]}),yield this.createUnsignedTx(f,"Sui.TokenBridge.Transfer")}}async*redeem(e,r,n=!0){const i=await Je(this.provider,this.tokenBridgeObjectId,r.payload.token.address.toUint8Array(),ce(r.payload.token.chain));if(!i)throw new Error("Unable to fetch token coinType");const[s,c]=await this.getPackageIds(),a=new ue,[o]=a.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[a.object(this.coreBridgeObjectId),a.pure(ze(ht(r))),a.object(pe)]}),[d]=a.moveCall({target:`${c}::vaa::verify_only_once`,arguments:[a.object(this.tokenBridgeObjectId),o]}),[u]=a.moveCall({target:`${c}::complete_transfer::authorize_transfer`,arguments:[a.object(this.tokenBridgeObjectId),d],typeArguments:[i]}),[g]=a.moveCall({target:`${c}::complete_transfer::redeem_relayer_payout`,arguments:[u],typeArguments:[i]});a.moveCall({target:`${c}::coin_utils::return_nonzero`,arguments:[g],typeArguments:[i]}),yield this.createUnsignedTx(a,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return ir(this.chain,Ge)}async getPackageIds(){return Promise.all([He(this.provider,this.coreBridgeObjectId),He(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,r,n){var a;if(n>8)throw new Error("Decimals is capped at 8");const i=(a=await gn(this.provider,this.tokenBridgeObjectId))==null?void 0:a.replace("0x","");if(!i)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const s="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+i+"00020106010000000001090b0031"+n.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[cn.encode(De.decode(s))],dependencies:["0x1","0x2",r,e].map(o=>Te(o))}}createUnsignedTx(e,r,n=!1){return new yr(e,this.network,this.chain,r,n)}}class tr{constructor(e,r,n,i){C(this,"network");C(this,"chain");C(this,"connection");C(this,"contracts");C(this,"tokenBridgeRelayerObjectId");C(this,"coreBridgeObjectId");C(this,"tokenBridgeObjectId");C(this,"fields");this.network=e,this.chain=r,this.connection=n,this.contracts=i;const{tokenBridge:s,tokenBridgeRelayer:c,coreBridge:a}=i;if(!s||!c||!a)throw new Error(`Some object IDs for ${r} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=c,this.tokenBridgeObjectId=s,this.coreBridgeObjectId=a}static async fromRpc(e,r){const[n,i]=await Q.chainFromRpc(e),s=r[i];if(s.network!==n)throw new Error(`Network mismatch for chain ${i}: ${s.network} != ${n}`);return new tr(n,i,e,s.contracts)}async*transfer(e,r,n,i,s){const a=new ge(oe(n)?Q.nativeTokenId(this.network,this.chain).address:n).getCoinType(),{coreBridge:o,tokenBridge:d}=await this.getPackageIds(),u=new ue,g=BigInt(0),[m]=u.splitCoins(u.gas,[u.pure(g)]),[y]=await(async()=>{if(oe(n))return u.splitCoins(u.gas,[u.pure(i)]);{const _=await Q.getCoins(this.connection,e,a),[U,...E]=_.filter(R=>R.coinType===a);if(U===void 0)throw new Error(`Coins array doesn't contain any coins of type ${a}`);const k=u.object(U.coinObjectId);return E.length&&u.mergeCoins(k,E.map(R=>u.object(R.coinObjectId))),u.splitCoins(k,[u.pure(i)])}})(),[w]=u.moveCall({target:`${d}::state::verified_asset`,arguments:[u.object(this.tokenBridgeObjectId)],typeArguments:[a]}),b=await this.getPackageId(),[f]=u.moveCall({target:`${b}::transfer::transfer_tokens_with_relay`,arguments:[u.object(this.tokenBridgeRelayerObjectId),y,w,u.pure.u64(s??0n),u.pure.u16(ce(r.chain)),u.pure.address(De.encode(r.address.toUint8Array(),!0)),u.pure.u32(123)],typeArguments:[a]}),[j]=u.moveCall({target:`${d}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[u.object(this.tokenBridgeObjectId),f],typeArguments:[a]});u.moveCall({target:`${o}::publish_message::publish_message`,arguments:[u.object(this.coreBridgeObjectId),m,j,u.object(pe)]}),yield this.createUnsignedTx(u,"AutomaticTokenBridge.transfer")}async*redeem(e,r){const{coreBridge:n,tokenBridge:i}=await this.getPackageIds(),{address:s,chain:c}=r.payload.token,a=await Je(this.connection,this.tokenBridgeObjectId,s.toUniversalAddress().toUint8Array(),ce(c));if(!a)throw new Error("Unable to fetch token coinType");const o=new ue,[d]=o.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[o.object(this.coreBridgeObjectId),o.pure(ze(ht(r))),o.object(pe)]}),[u]=o.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[o.object(this.tokenBridgeObjectId),d]}),[g]=o.moveCall({target:`${i}::complete_transfer_with_payload::authorize_transfer`,arguments:[o.object(this.tokenBridgeObjectId),u],typeArguments:[a]}),m=await this.getPackageId();o.moveCall({target:`${m}::redeem::complete_transfer`,arguments:[o.object(this.tokenBridgeRelayerObjectId),g],typeArguments:[a]}),yield this.createUnsignedTx(o,"AutomaticTokenBridge.redeem")}async getRelayerFee(e,r){const n=oe(r)?Q.nativeTokenId(this.network,this.chain):r,i=await this.getTokenInfo(n.toString());if(i===null)throw new Error("Unsupported token for relay");const s=await this.getFields(),c=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(un.encode("relayer_fees"))}});if(!c.data||!c.data.content)throw c.error?new Error("Failed to get relayer fees: "+JSON.stringify(c.error)):new Error("Unable to compute relayer fee");const{content:a}=c.data;if(!H(a)||!pn(a.fields.id))throw new Error("Unable to compute relayer fee");const o=await this.connection.getDynamicFieldObject({parentId:a.fields.id.id,name:{type:"u16",value:ce(e)}});if(!o.data||!o.data.content)throw o.error?new Error("Failed to get relayer fees: "+JSON.stringify(c.error)):new Error("Unable to compute relayer fee");const{content:d}=o.data;if(!H(d))throw new Error("Unable to compute relayer fee");const u=await Q.getDecimals(this.chain,this.connection,r.toString()),g=i.swap_rate,m=s.relayer_fee_precision,y=s.swap_rate_precision,w=d.fields.value;return 10n**BigInt(u)*BigInt(w)*BigInt(y)/(BigInt(g)*BigInt(m))}async maxSwapAmount(e){var o,d;const n=(oe(e)?Q.nativeTokenId(this.network,this.chain):e).toString(),i=await this.connection.getCoinMetadata({coinType:n});if(!i)throw new Error("metadata is null");const s=await this.getPackageId(),c=new ue;c.moveCall({target:`${s}::redeem::calculate_max_swap_amount_in`,arguments:[c.object(this.tokenBridgeRelayerObjectId),c.pure(i.decimals)],typeArguments:[n]});const a=await this.connection.devInspectTransactionBlock({transactionBlock:c,sender:De.encode(new Uint8Array(32))});if(!a.results||a.results.length==0||!((o=a.results[0])!=null&&o.returnValues)||((d=a.results[0])==null?void 0:d.returnValues.length)!==1)throw Error("swap rate not set");return sr.decode(new Uint8Array(a.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,r){var d,u;const i=(oe(e)?Q.nativeTokenId(this.network,this.chain):e).toString(),s=await this.connection.getCoinMetadata({coinType:i});if(!s)throw new Error("metadata is null");const c=await this.getPackageId(),a=new ue;a.moveCall({target:`${c}::redeem::calculate_native_swap_amount_out`,arguments:[a.object(this.tokenBridgeRelayerObjectId),a.pure(r),a.pure(s.decimals)],typeArguments:[i]});const o=await this.connection.devInspectTransactionBlock({transactionBlock:a,sender:De.encode(new Uint8Array(32))});if(!o.results||o.results.length==0||!((d=o.results[0])!=null&&d.returnValues)||((u=o.results[0])==null?void 0:u.returnValues.length)!==1)throw Error("swap rate not set");return sr.decode(new Uint8Array(o.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){const r=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:r})).data.map(s=>{const{address:c,module:a,name:o}=$r(s.objectType).typeParams[0];return new ge([c,a,o].join(dn))})}async isRegisteredToken(e){const r=new ge(oe(e)?Q.nativeTokenId(this.network,this.chain).address:e).unwrap();try{return await this.getTokenInfo(r)!==null}catch(n){console.error(n)}return!1}async getTokenInfo(e){var o;const r=await this.getFields(),i=new ge(r.registered_tokens.type).getPackageId(),s=r.registered_tokens.fields.id.id,c=new ge(e),a=pr(ar,c.unwrap())?ar:c.getCoinType();try{const d=await this.connection.getDynamicFieldObject({parentId:s,name:{type:`${i}::registered_tokens::Key<${a}>`,value:{dummy_field:!1}}});if(d.error)throw new Error("Failed to get token info: "+JSON.stringify(d.error));if(!d.data||!d.data.content)throw new Error("Failed to get token info: "+JSON.stringify(d));const{content:u}=d.data;return H(u)&&H(u.fields.value)?u.fields.value.fields:null}catch(d){if((d==null?void 0:d.code)===-32e3&&((o=d.message)!=null&&o.includes("RPC Error")))return console.error(d),null;throw d}}async getFields(){if(!this.fields){const e=await tt(this.connection,this.tokenBridgeRelayerObjectId);if(e===null)throw new Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){const e=await this.getFields();return new ge(e.registered_tokens.type).getPackageId()}async getPackageIds(){const[e,r]=await Promise.all([He(this.connection,this.coreBridgeObjectId),He(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:r}}createUnsignedTx(e,r,n=!1){return new yr(e,this.network,this.chain,r,n)}}gr("Sui","TokenBridge",er);gr("Sui","AutomaticTokenBridge",tr);export{tr as SuiAutomaticTokenBridge,er as SuiTokenBridge,Je as getTokenCoinType,fr as getTokenFromTokenRegistry};
