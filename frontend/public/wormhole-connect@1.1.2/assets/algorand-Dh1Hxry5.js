const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-Cf0vrSY4.js","main.js","main.css","assets/index-Bvt7q8n_.js"])))=>i.map(i=>d[i]);
var A=Object.defineProperty;var C=(e,n,t)=>n in e?A(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var l=(e,n,t)=>C(e,typeof n!="symbol"?n+"":n,t);import{ay as x,az as R,bz as w,aB as S,bA as i,aC as T,bB as y,aE as E,aF as p,bC as h,aG as j,aJ as B,bD as D,bE as N,_,an as k}from"../main.js";class I extends x{}const g=class g extends R{constructor(n,t){super(n,t??S(n,g._platform))}getRpc(n){if(n in this.config)return new i.Algodv2("",this.config[n].rpc);throw new Error("No configuration available for chain: "+n)}getChain(n){if(n in this.config)return new I(n,this);throw new Error("No configuration available for chain: "+n)}static nativeTokenId(n,t){if(!g.isSupportedChain(t))throw new Error(`invalid chain for Algorand: ${t}`);return T.chainAddress(t,y)}static isNativeTokenId(n,t,o){return!g.isSupportedChain(t)||o.chain!==t?!1:this.nativeTokenId(n,t)==o}static isSupportedChain(n){return E(n)===g._platform}static async getDecimals(n,t,o){const a=p(o)?0:new h(o).toInt();if(a===0)return j(g._platform);const d=await t.getAssetByID(a).do(),r=i.modelsv2.Asset.from_obj_for_encoding(d);if(!r.params||!r.params.decimals)throw new Error("Could not fetch token details");return Number(r.params.decimals)}static async getBalance(n,t,o,a){const d=p(a)?0:new h(a).toInt();if(d===0){const c=await t.accountInformation(o).do(),u=i.modelsv2.Account.from_obj_for_encoding(c);return BigInt(u.amount)}const r=await t.accountAssetInformation(o,d).do(),s=i.modelsv2.AssetHolding.from_obj_for_encoding(r);return BigInt(s.amount)}static async getBalances(n,t,o,a){let d;if(a.includes("native")){const s=await t.accountInformation(o).do(),c=i.modelsv2.Account.from_obj_for_encoding(s);d=BigInt(c.amount)}return a.map(async s=>{if(p(s))return{native:d};const c=new h(s).toInt(),u=await t.accountAssetInformation(o,c).do(),f=i.modelsv2.AssetHolding.from_obj_for_encoding(u);return BigInt(f.amount)}).reduce((s,c)=>Object.assign(s,c),{})}static async sendWait(n,t,o){const r=o.map((f,b)=>i.decodeSignedTransaction(f)).map((f,b)=>f.txn.txID()),{txId:s}=await t.sendRawTransaction(o).do();if(!s)throw new Error("Transaction(s) failed to send");const c=await i.waitForConfirmation(t,s,4);if(!i.modelsv2.PendingTransactionResponse.from_obj_for_encoding(c).confirmedRound)throw new Error("Transaction(s) could not be confirmed in 4 rounds");return r}static async getLatestBlock(n){const t=await n.status().do(),o=i.modelsv2.NodeStatusResponse.from_obj_for_encoding(t);if(!o.lastRound)throw new Error("Error getting status from node");return Number(o.lastRound)}static async getLatestFinalizedBlock(n){const t=await n.status().do(),o=i.modelsv2.NodeStatusResponse.from_obj_for_encoding(t);if(!o.lastRound)throw new Error("Error getting status from node");return Number(o.lastRound)}static chainFromChainId(n){const t=B(g._platform,n);if(t===void 0)throw new Error(`Unknown native chain id ${n}`);const[o,a]=t;return[o,a]}static async chainFromRpc(n){const t=await n.versionsCheck().do(),o=i.modelsv2.Version.from_obj_for_encoding(t);return this.chainFromChainId(o.genesisId)}};l(g,"_platform",w);let m=g;async function $(e,n){const[t,o]=await m.chainFromRpc(e);return new F(o,e,n)}class F{constructor(n,t,o,a=!1){l(this,"_chain");l(this,"_debug");l(this,"_account");this._chain=n,this._debug=a,this._account=D(o)}chain(){return this._chain}address(){return this._account.addr}async sign(n){const t=[],o=n.map((r,s)=>r.transaction.tx),a=N(o),d=n.map((r,s)=>(r.transaction.tx=a[s],r));for(const r of d){const{description:s,transaction:c}=r,{tx:u,signer:f}=c;this._debug&&(console.log(u._getDictForDisplay()),console.log(u.txID())),f?(this._debug&&console.log(`Signing: ${s} with signer ${f.address} for address ${this.address()}`),t.push(await f.signTxn(u))):(this._debug&&console.log(`Signing: ${s} without signer for address ${this.address()}`),t.push(u.signTxn(this._account.sk)))}return t}}const P={Address:h,Platform:m,getSigner:$,protocols:{WormholeCore:()=>_(()=>import("./index-Cf0vrSY4.js").then(e=>e.i),__vite__mapDeps([0,1,2])),TokenBridge:()=>_(()=>import("./index-Bvt7q8n_.js"),__vite__mapDeps([3,0,1,2]))},getChain:(e,n,t)=>new I(n,new m(e,k(e,w,{[n]:t})))},L=Object.freeze(Object.defineProperty({__proto__:null,default:P},Symbol.toStringTag,{value:"Module"}));export{m as A,L as a};
